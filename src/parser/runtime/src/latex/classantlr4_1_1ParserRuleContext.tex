\hypertarget{classantlr4_1_1ParserRuleContext}{}\section{antlr4\+:\+:Parser\+Rule\+Context Class Reference}
\label{classantlr4_1_1ParserRuleContext}\index{antlr4\+::\+Parser\+Rule\+Context@{antlr4\+::\+Parser\+Rule\+Context}}


A rule invocation record for parsing.  




{\ttfamily \#include $<$Parser\+Rule\+Context.\+h$>$}



Inheritance diagram for antlr4\+:\+:Parser\+Rule\+Context\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classantlr4_1_1ParserRuleContext__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for antlr4\+:\+:Parser\+Rule\+Context\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=311pt]{classantlr4_1_1ParserRuleContext__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classantlr4_1_1ParserRuleContext_a13e9a86b7d2ccb34c2d50550deb4b36d}\label{classantlr4_1_1ParserRuleContext_a13e9a86b7d2ccb34c2d50550deb4b36d}} 
{\bfseries Parser\+Rule\+Context} (\hyperlink{classantlr4_1_1ParserRuleContext}{Parser\+Rule\+Context} $\ast$\hyperlink{classantlr4_1_1tree_1_1ParseTree_a83402632670316b68280c04e6be70d50}{parent}, size\+\_\+t invoking\+State\+Number)
\item 
virtual void \hyperlink{classantlr4_1_1ParserRuleContext_a32e160f0c98a6475424ffe193040cdae}{copy\+From} (\hyperlink{classantlr4_1_1ParserRuleContext}{Parser\+Rule\+Context} $\ast$ctx)
\item 
\mbox{\Hypertarget{classantlr4_1_1ParserRuleContext_aee63c438f6be836d5592cf1f045c735f}\label{classantlr4_1_1ParserRuleContext_aee63c438f6be836d5592cf1f045c735f}} 
virtual void {\bfseries enter\+Rule} (\hyperlink{classantlr4_1_1tree_1_1ParseTreeListener}{tree\+::\+Parse\+Tree\+Listener} $\ast$listener)
\item 
\mbox{\Hypertarget{classantlr4_1_1ParserRuleContext_acd661fddddc4e72900091d23f6c81afe}\label{classantlr4_1_1ParserRuleContext_acd661fddddc4e72900091d23f6c81afe}} 
virtual void {\bfseries exit\+Rule} (\hyperlink{classantlr4_1_1tree_1_1ParseTreeListener}{tree\+::\+Parse\+Tree\+Listener} $\ast$listener)
\item 
\hyperlink{classantlr4_1_1tree_1_1TerminalNode}{tree\+::\+Terminal\+Node} $\ast$ \hyperlink{classantlr4_1_1ParserRuleContext_a402addbef275358076e63253db77b0c4}{add\+Child} (\hyperlink{classantlr4_1_1tree_1_1TerminalNode}{tree\+::\+Terminal\+Node} $\ast$t)
\item 
\mbox{\Hypertarget{classantlr4_1_1ParserRuleContext_ab31addd41aee593b86d5e15c243c084e}\label{classantlr4_1_1ParserRuleContext_ab31addd41aee593b86d5e15c243c084e}} 
\hyperlink{classantlr4_1_1RuleContext}{Rule\+Context} $\ast$ {\bfseries add\+Child} (\hyperlink{classantlr4_1_1RuleContext}{Rule\+Context} $\ast$rule\+Invocation)
\item 
virtual void \hyperlink{classantlr4_1_1ParserRuleContext_a0d7e71fc8e12b036014820a1d530b8bb}{remove\+Last\+Child} ()
\item 
\mbox{\Hypertarget{classantlr4_1_1ParserRuleContext_a7c7888fb2f93de0a8d68101192a1eb51}\label{classantlr4_1_1ParserRuleContext_a7c7888fb2f93de0a8d68101192a1eb51}} 
virtual \hyperlink{classantlr4_1_1tree_1_1TerminalNode}{tree\+::\+Terminal\+Node} $\ast$ {\bfseries get\+Token} (size\+\_\+t ttype, std\+::size\+\_\+t i)
\item 
\mbox{\Hypertarget{classantlr4_1_1ParserRuleContext_a642538341e37d3391db1ad558cbb30ab}\label{classantlr4_1_1ParserRuleContext_a642538341e37d3391db1ad558cbb30ab}} 
virtual std\+::vector$<$ \hyperlink{classantlr4_1_1tree_1_1TerminalNode}{tree\+::\+Terminal\+Node} $\ast$ $>$ {\bfseries get\+Tokens} (size\+\_\+t ttype)
\item 
\mbox{\Hypertarget{classantlr4_1_1ParserRuleContext_a6556b9859491c8b0ff166af71218e2d5}\label{classantlr4_1_1ParserRuleContext_a6556b9859491c8b0ff166af71218e2d5}} 
{\footnotesize template$<$typename T $>$ }\\T $\ast$ {\bfseries get\+Rule\+Context} (size\+\_\+t i)
\item 
\mbox{\Hypertarget{classantlr4_1_1ParserRuleContext_a3e62d59955f25f81d6b0d79111a9fab7}\label{classantlr4_1_1ParserRuleContext_a3e62d59955f25f81d6b0d79111a9fab7}} 
{\footnotesize template$<$typename T $>$ }\\std\+::vector$<$ T $\ast$ $>$ {\bfseries get\+Rule\+Contexts} ()
\item 
\mbox{\Hypertarget{classantlr4_1_1ParserRuleContext_a8d1858e04ce2a478986ded6dced62dc4}\label{classantlr4_1_1ParserRuleContext_a8d1858e04ce2a478986ded6dced62dc4}} 
virtual \hyperlink{classantlr4_1_1misc_1_1Interval}{misc\+::\+Interval} {\bfseries get\+Source\+Interval} () override
\item 
virtual \hyperlink{classantlr4_1_1Token}{Token} $\ast$ \hyperlink{classantlr4_1_1ParserRuleContext_a069cff86aad00ea0618985e78291e8fa}{get\+Start} ()
\item 
virtual \hyperlink{classantlr4_1_1Token}{Token} $\ast$ \hyperlink{classantlr4_1_1ParserRuleContext_a51432e71c46225602c504768c50ad776}{get\+Stop} ()
\item 
virtual std\+::string \hyperlink{classantlr4_1_1ParserRuleContext_a36fdb4f19d0b2dce76164b3ffee6d81e}{to\+Info\+String} (\hyperlink{classantlr4_1_1Parser}{Parser} $\ast$recognizer)
\begin{DoxyCompactList}\small\item\em Used for rule context info debugging during parse-\/time, not so much for A\+TN debugging \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classantlr4_1_1Token}{Token} $\ast$ \hyperlink{classantlr4_1_1ParserRuleContext_a2e3580cf80f49dc92cec0ad4c8ea9ba0}{start}
\begin{DoxyCompactList}\small\item\em For debugging/tracing purposes, we want to track all of the nodes in the A\+TN traversed by the parser for a particular rule. This list indicates the sequence of A\+TN nodes used to match the elements of the children list. This list does not include A\+TN nodes and other rules used to match rule invocations. It traces the rule invocation node itself but nothing inside that other rule\textquotesingle{}s A\+TN submachine. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classantlr4_1_1ParserRuleContext_ab5a3e2dbb7315e1245be9b90f93a53b5}\label{classantlr4_1_1ParserRuleContext_ab5a3e2dbb7315e1245be9b90f93a53b5}} 
\hyperlink{classantlr4_1_1Token}{Token} $\ast$ {\bfseries stop}
\item 
std\+::exception\+\_\+ptr \hyperlink{classantlr4_1_1ParserRuleContext_ac427da1597154161775151dfee4069fa}{exception}
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classantlr4_1_1ParserRuleContext_a41d719f482d60677ec1fbf08b7e5e77c}\label{classantlr4_1_1ParserRuleContext_a41d719f482d60677ec1fbf08b7e5e77c}} 
static \hyperlink{classantlr4_1_1ParserRuleContext}{Parser\+Rule\+Context} {\bfseries E\+M\+P\+TY}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
A rule invocation record for parsing. 

Contains all of the information about the current rule not stored in the \hyperlink{classantlr4_1_1RuleContext}{Rule\+Context}. It handles parse tree children list, Any A\+TN state tracing, and the default values available for rule invocatons\+: start, stop, rule index, current alt number.

Subclasses made for each rule and grammar track the parameters, return values, locals, and labels specific to that rule. These are the objects that are returned from rules.

Note text is not an actual field of a rule return value; it is computed from start and stop using the input stream\textquotesingle{}s to\+String() method. I could add a ctor to this so that we can pass in and store the input stream, but I\textquotesingle{}m not sure we want to do that. It would seem to be undefined to get the .text property anyway if the rule matches tokens from multiple input streams.

I do not use getters for fields of objects that are used simply to group values such as this aggregate. The getters/setters are there to satisfy the superclass interface. 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classantlr4_1_1ParserRuleContext_a402addbef275358076e63253db77b0c4}\label{classantlr4_1_1ParserRuleContext_a402addbef275358076e63253db77b0c4}} 
\index{antlr4\+::\+Parser\+Rule\+Context@{antlr4\+::\+Parser\+Rule\+Context}!add\+Child@{add\+Child}}
\index{add\+Child@{add\+Child}!antlr4\+::\+Parser\+Rule\+Context@{antlr4\+::\+Parser\+Rule\+Context}}
\subsubsection{\texorpdfstring{add\+Child()}{addChild()}}
{\footnotesize\ttfamily \hyperlink{classantlr4_1_1tree_1_1TerminalNode}{tree\+::\+Terminal\+Node} $\ast$ Parser\+Rule\+Context\+::add\+Child (\begin{DoxyParamCaption}\item[{\hyperlink{classantlr4_1_1tree_1_1TerminalNode}{tree\+::\+Terminal\+Node} $\ast$}]{t }\end{DoxyParamCaption})}

Add a token leaf node child and force its parent to be this node. \mbox{\Hypertarget{classantlr4_1_1ParserRuleContext_a32e160f0c98a6475424ffe193040cdae}\label{classantlr4_1_1ParserRuleContext_a32e160f0c98a6475424ffe193040cdae}} 
\index{antlr4\+::\+Parser\+Rule\+Context@{antlr4\+::\+Parser\+Rule\+Context}!copy\+From@{copy\+From}}
\index{copy\+From@{copy\+From}!antlr4\+::\+Parser\+Rule\+Context@{antlr4\+::\+Parser\+Rule\+Context}}
\subsubsection{\texorpdfstring{copy\+From()}{copyFrom()}}
{\footnotesize\ttfamily void Parser\+Rule\+Context\+::copy\+From (\begin{DoxyParamCaption}\item[{\hyperlink{classantlr4_1_1ParserRuleContext}{Parser\+Rule\+Context} $\ast$}]{ctx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

C\+O\+PY a ctx (I\textquotesingle{}m deliberately not using copy constructor) to avoid confusion with creating node with parent. Does not copy children (except error leaves). \mbox{\Hypertarget{classantlr4_1_1ParserRuleContext_a069cff86aad00ea0618985e78291e8fa}\label{classantlr4_1_1ParserRuleContext_a069cff86aad00ea0618985e78291e8fa}} 
\index{antlr4\+::\+Parser\+Rule\+Context@{antlr4\+::\+Parser\+Rule\+Context}!get\+Start@{get\+Start}}
\index{get\+Start@{get\+Start}!antlr4\+::\+Parser\+Rule\+Context@{antlr4\+::\+Parser\+Rule\+Context}}
\subsubsection{\texorpdfstring{get\+Start()}{getStart()}}
{\footnotesize\ttfamily \hyperlink{classantlr4_1_1Token}{Token} $\ast$ Parser\+Rule\+Context\+::get\+Start (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Get the initial token in this context. Note that the range from start to stop is inclusive, so for rules that do not consume anything (for example, zero length or error productions) this token may exceed stop. \mbox{\Hypertarget{classantlr4_1_1ParserRuleContext_a51432e71c46225602c504768c50ad776}\label{classantlr4_1_1ParserRuleContext_a51432e71c46225602c504768c50ad776}} 
\index{antlr4\+::\+Parser\+Rule\+Context@{antlr4\+::\+Parser\+Rule\+Context}!get\+Stop@{get\+Stop}}
\index{get\+Stop@{get\+Stop}!antlr4\+::\+Parser\+Rule\+Context@{antlr4\+::\+Parser\+Rule\+Context}}
\subsubsection{\texorpdfstring{get\+Stop()}{getStop()}}
{\footnotesize\ttfamily \hyperlink{classantlr4_1_1Token}{Token} $\ast$ Parser\+Rule\+Context\+::get\+Stop (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Get the final token in this context. Note that the range from start to stop is inclusive, so for rules that do not consume anything (for example, zero length or error productions) this token may precede start. \mbox{\Hypertarget{classantlr4_1_1ParserRuleContext_a0d7e71fc8e12b036014820a1d530b8bb}\label{classantlr4_1_1ParserRuleContext_a0d7e71fc8e12b036014820a1d530b8bb}} 
\index{antlr4\+::\+Parser\+Rule\+Context@{antlr4\+::\+Parser\+Rule\+Context}!remove\+Last\+Child@{remove\+Last\+Child}}
\index{remove\+Last\+Child@{remove\+Last\+Child}!antlr4\+::\+Parser\+Rule\+Context@{antlr4\+::\+Parser\+Rule\+Context}}
\subsubsection{\texorpdfstring{remove\+Last\+Child()}{removeLastChild()}}
{\footnotesize\ttfamily void Parser\+Rule\+Context\+::remove\+Last\+Child (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Used by enter\+Outer\+Alt to toss out a \hyperlink{classantlr4_1_1RuleContext}{Rule\+Context} previously added as we entered a rule. If we have \# label, we will need to remove generic rule\+Context object. \mbox{\Hypertarget{classantlr4_1_1ParserRuleContext_a36fdb4f19d0b2dce76164b3ffee6d81e}\label{classantlr4_1_1ParserRuleContext_a36fdb4f19d0b2dce76164b3ffee6d81e}} 
\index{antlr4\+::\+Parser\+Rule\+Context@{antlr4\+::\+Parser\+Rule\+Context}!to\+Info\+String@{to\+Info\+String}}
\index{to\+Info\+String@{to\+Info\+String}!antlr4\+::\+Parser\+Rule\+Context@{antlr4\+::\+Parser\+Rule\+Context}}
\subsubsection{\texorpdfstring{to\+Info\+String()}{toInfoString()}}
{\footnotesize\ttfamily std\+::string Parser\+Rule\+Context\+::to\+Info\+String (\begin{DoxyParamCaption}\item[{\hyperlink{classantlr4_1_1Parser}{Parser} $\ast$}]{recognizer }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Used for rule context info debugging during parse-\/time, not so much for A\+TN debugging 



\subsection{Member Data Documentation}
\mbox{\Hypertarget{classantlr4_1_1ParserRuleContext_ac427da1597154161775151dfee4069fa}\label{classantlr4_1_1ParserRuleContext_ac427da1597154161775151dfee4069fa}} 
\index{antlr4\+::\+Parser\+Rule\+Context@{antlr4\+::\+Parser\+Rule\+Context}!exception@{exception}}
\index{exception@{exception}!antlr4\+::\+Parser\+Rule\+Context@{antlr4\+::\+Parser\+Rule\+Context}}
\subsubsection{\texorpdfstring{exception}{exception}}
{\footnotesize\ttfamily std\+::exception\+\_\+ptr antlr4\+::\+Parser\+Rule\+Context\+::exception}

The exception that forced this rule to return. If the rule successfully completed, this is \char`\"{}null exception pointer\char`\"{}. \mbox{\Hypertarget{classantlr4_1_1ParserRuleContext_a2e3580cf80f49dc92cec0ad4c8ea9ba0}\label{classantlr4_1_1ParserRuleContext_a2e3580cf80f49dc92cec0ad4c8ea9ba0}} 
\index{antlr4\+::\+Parser\+Rule\+Context@{antlr4\+::\+Parser\+Rule\+Context}!start@{start}}
\index{start@{start}!antlr4\+::\+Parser\+Rule\+Context@{antlr4\+::\+Parser\+Rule\+Context}}
\subsubsection{\texorpdfstring{start}{start}}
{\footnotesize\ttfamily \hyperlink{classantlr4_1_1Token}{Token}$\ast$ antlr4\+::\+Parser\+Rule\+Context\+::start}



For debugging/tracing purposes, we want to track all of the nodes in the A\+TN traversed by the parser for a particular rule. This list indicates the sequence of A\+TN nodes used to match the elements of the children list. This list does not include A\+TN nodes and other rules used to match rule invocations. It traces the rule invocation node itself but nothing inside that other rule\textquotesingle{}s A\+TN submachine. 

There is N\+OT a one-\/to-\/one correspondence between the children and states list. There are typically many nodes in the A\+TN traversed for each element in the children list. For example, for a rule invocation there is the invoking state and the following state.

The parser set\+State() method updates field s and adds it to this list if we are debugging/tracing.

This does not trace states visited during prediction. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
Parser\+Rule\+Context.\+h\item 
Parser\+Rule\+Context.\+cpp\end{DoxyCompactItemize}
