\hypertarget{classantlr4_1_1RuleContext}{}\section{antlr4\+:\+:Rule\+Context Class Reference}
\label{classantlr4_1_1RuleContext}\index{antlr4\+::\+Rule\+Context@{antlr4\+::\+Rule\+Context}}


{\ttfamily \#include $<$Rule\+Context.\+h$>$}



Inheritance diagram for antlr4\+:\+:Rule\+Context\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classantlr4_1_1RuleContext__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for antlr4\+:\+:Rule\+Context\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=243pt]{classantlr4_1_1RuleContext__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classantlr4_1_1RuleContext_a3a8366fbdf9e4782e0770cafe361ef4d}\label{classantlr4_1_1RuleContext_a3a8366fbdf9e4782e0770cafe361ef4d}} 
{\bfseries Rule\+Context} (\hyperlink{classantlr4_1_1RuleContext}{Rule\+Context} $\ast$\hyperlink{classantlr4_1_1tree_1_1ParseTree_a83402632670316b68280c04e6be70d50}{parent}, size\+\_\+t \hyperlink{classantlr4_1_1RuleContext_a2c4b8b84636c681f98dcd86d5c5a8459}{invoking\+State})
\item 
\mbox{\Hypertarget{classantlr4_1_1RuleContext_a84b5f07f832e628025b22bd1554c239c}\label{classantlr4_1_1RuleContext_a84b5f07f832e628025b22bd1554c239c}} 
virtual int {\bfseries depth} ()
\item 
\mbox{\Hypertarget{classantlr4_1_1RuleContext_a9b85b3df53a724a0a3cc2b8bc949045e}\label{classantlr4_1_1RuleContext_a9b85b3df53a724a0a3cc2b8bc949045e}} 
virtual bool \hyperlink{classantlr4_1_1RuleContext_a9b85b3df53a724a0a3cc2b8bc949045e}{is\+Empty} ()
\begin{DoxyCompactList}\small\item\em A context is empty if there is no invoking state; meaning nobody called current context. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classantlr4_1_1RuleContext_a7d1c4ec653dabbe03cec49275c9a5915}\label{classantlr4_1_1RuleContext_a7d1c4ec653dabbe03cec49275c9a5915}} 
virtual \hyperlink{classantlr4_1_1misc_1_1Interval}{misc\+::\+Interval} {\bfseries get\+Source\+Interval} () override
\item 
\mbox{\Hypertarget{classantlr4_1_1RuleContext_a33302ceb47c02e06e24beffac9b8564e}\label{classantlr4_1_1RuleContext_a33302ceb47c02e06e24beffac9b8564e}} 
virtual std\+::string {\bfseries get\+Text} () override
\item 
\mbox{\Hypertarget{classantlr4_1_1RuleContext_ab3c47d330254d4224073408522ac6956}\label{classantlr4_1_1RuleContext_ab3c47d330254d4224073408522ac6956}} 
virtual size\+\_\+t {\bfseries get\+Rule\+Index} () const
\item 
virtual size\+\_\+t \hyperlink{classantlr4_1_1RuleContext_abb31efff7ed16c524298b9052c75e8f7}{get\+Alt\+Number} () const
\item 
virtual void \hyperlink{classantlr4_1_1RuleContext_a13942e9b3fc17ab566e92e6c8c2d88e2}{set\+Alt\+Number} (size\+\_\+t alt\+Number)
\item 
\mbox{\Hypertarget{classantlr4_1_1RuleContext_a8188a57118653c6dcba7de466e572bfd}\label{classantlr4_1_1RuleContext_a8188a57118653c6dcba7de466e572bfd}} 
virtual \hyperlink{structantlrcpp_1_1Any}{antlrcpp\+::\+Any} {\bfseries accept} (tree\+::\+Parse\+Tree\+Visitor $\ast$visitor) override
\item 
virtual std\+::string \hyperlink{classantlr4_1_1RuleContext_ac4ba5cd65bf384baf9c27be9b14ebcfb}{to\+String\+Tree} (\hyperlink{classantlr4_1_1Parser}{Parser} $\ast$recog) override
\begin{DoxyCompactList}\small\item\em Print out a whole tree, not just a node, in L\+I\+SP format (root child1 .. childN). Print just a node if this is a leaf. We have to know the recognizer so we can get rule names. \end{DoxyCompactList}\item 
virtual std\+::string \hyperlink{classantlr4_1_1RuleContext_abcf82cbd07b59781b819a315a862c5a1}{to\+String\+Tree} (std\+::vector$<$ std\+::string $>$ \&rule\+Names)
\begin{DoxyCompactList}\small\item\em Print out a whole tree, not just a node, in L\+I\+SP format (root child1 .. childN). Print just a node if this is a leaf. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classantlr4_1_1RuleContext_ab94a4fb68e964f80eeeca75c24708742}\label{classantlr4_1_1RuleContext_ab94a4fb68e964f80eeeca75c24708742}} 
virtual std\+::string {\bfseries to\+String\+Tree} () override
\item 
\mbox{\Hypertarget{classantlr4_1_1RuleContext_a44d95ea08da34f2539fb84c9386cc48f}\label{classantlr4_1_1RuleContext_a44d95ea08da34f2539fb84c9386cc48f}} 
virtual std\+::string {\bfseries to\+String} () override
\item 
\mbox{\Hypertarget{classantlr4_1_1RuleContext_a5d3400ab115874c8ae7c8bb9b23b88b6}\label{classantlr4_1_1RuleContext_a5d3400ab115874c8ae7c8bb9b23b88b6}} 
std\+::string {\bfseries to\+String} (\hyperlink{classantlr4_1_1Recognizer}{Recognizer} $\ast$recog)
\item 
\mbox{\Hypertarget{classantlr4_1_1RuleContext_a73fb65c70dea4528092c6fe5122a04bf}\label{classantlr4_1_1RuleContext_a73fb65c70dea4528092c6fe5122a04bf}} 
std\+::string {\bfseries to\+String} (const std\+::vector$<$ std\+::string $>$ \&rule\+Names)
\item 
\mbox{\Hypertarget{classantlr4_1_1RuleContext_abe90e4ee8e178f95faf2fd2f36b292be}\label{classantlr4_1_1RuleContext_abe90e4ee8e178f95faf2fd2f36b292be}} 
std\+::string {\bfseries to\+String} (\hyperlink{classantlr4_1_1Recognizer}{Recognizer} $\ast$recog, \hyperlink{classantlr4_1_1RuleContext}{Rule\+Context} $\ast$stop)
\item 
\mbox{\Hypertarget{classantlr4_1_1RuleContext_ac62fa052c96061993df78332adac0430}\label{classantlr4_1_1RuleContext_ac62fa052c96061993df78332adac0430}} 
virtual std\+::string {\bfseries to\+String} (const std\+::vector$<$ std\+::string $>$ \&rule\+Names, \hyperlink{classantlr4_1_1RuleContext}{Rule\+Context} $\ast$stop)
\item 
\mbox{\Hypertarget{classantlr4_1_1RuleContext_a78d3283be6274bee157fd0a5f5e90001}\label{classantlr4_1_1RuleContext_a78d3283be6274bee157fd0a5f5e90001}} 
bool {\bfseries operator==} (const \hyperlink{classantlr4_1_1RuleContext}{Rule\+Context} \&other)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
size\+\_\+t \hyperlink{classantlr4_1_1RuleContext_a2c4b8b84636c681f98dcd86d5c5a8459}{invoking\+State}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
A rule context is a record of a single rule invocation.

We form a stack of these context objects using the parent pointer. A parent pointer of null indicates that the current context is the bottom of the stack. The \hyperlink{classantlr4_1_1ParserRuleContext}{Parser\+Rule\+Context} subclass as a children list so that we can turn this data structure into a tree.

The root node always has a null pointer and invoking\+State of -\/1.

Upon entry to parsing, the first invoked rule function creates a context object (asubclass specialized for that rule such as S\+Context) and makes it the root of a parse tree, recorded by field Parser.\+\_\+ctx.

public final S\+Context s() throws Recognition\+Exception \{ S\+Context \+\_\+localctx = new S\+Context(\+\_\+ctx, get\+State()); $<$-- create new node enter\+Rule(\+\_\+localctx, 0, R\+U\+L\+E\+\_\+s); $<$-- push it ... exit\+Rule(); $<$-- pop back to \+\_\+localctx return \+\_\+localctx; \}

A subsequent rule invocation of r from the start rule s pushes a new context object for r whose parent points at s and use invoking state is the state with r emanating as edge label.

The invoking\+State fields from a context object to the root together form a stack of rule indication states where the root (bottom of the stack) has a -\/1 sentinel value. If we invoke start symbol s then call r1, which calls r2, the would look like this\+:

S\+Context\mbox{[}-\/1\mbox{]} $<$-\/ root node (bottom of the stack) R1\+Context\mbox{[}p\mbox{]} $<$-\/ p in rule s called r1 R2\+Context\mbox{[}q\mbox{]} $<$-\/ q in rule r1 called r2

So the top of the stack, \+\_\+ctx, represents a call to the current rule and it holds the return address from another rule that invoke to this rule. To invoke a rule, we must always have a current context.

The parent contexts are useful for computing lookahead sets and getting error information.

These objects are used during parsing and prediction. For the special case of parsers, we use the subclass \hyperlink{classantlr4_1_1ParserRuleContext}{Parser\+Rule\+Context}.

\begin{DoxySeeAlso}{See also}
\hyperlink{classantlr4_1_1ParserRuleContext}{Parser\+Rule\+Context} 
\end{DoxySeeAlso}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classantlr4_1_1RuleContext_abb31efff7ed16c524298b9052c75e8f7}\label{classantlr4_1_1RuleContext_abb31efff7ed16c524298b9052c75e8f7}} 
\index{antlr4\+::\+Rule\+Context@{antlr4\+::\+Rule\+Context}!get\+Alt\+Number@{get\+Alt\+Number}}
\index{get\+Alt\+Number@{get\+Alt\+Number}!antlr4\+::\+Rule\+Context@{antlr4\+::\+Rule\+Context}}
\subsubsection{\texorpdfstring{get\+Alt\+Number()}{getAltNumber()}}
{\footnotesize\ttfamily size\+\_\+t Rule\+Context\+::get\+Alt\+Number (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}

For rule associated with this parse tree internal node, return the outer alternative number used to match the input. Default implementation does not compute nor store this alt num. Create a subclass of \hyperlink{classantlr4_1_1ParserRuleContext}{Parser\+Rule\+Context} with backing field and set option context\+Super\+Class. to set it.

\begin{DoxySince}{Since}
4.\+5.\+3 
\end{DoxySince}


Reimplemented in \hyperlink{classantlr4_1_1RuleContextWithAltNum_a6efffe072fe42ba82c405545db4e5510}{antlr4\+::\+Rule\+Context\+With\+Alt\+Num}.

\mbox{\Hypertarget{classantlr4_1_1RuleContext_a13942e9b3fc17ab566e92e6c8c2d88e2}\label{classantlr4_1_1RuleContext_a13942e9b3fc17ab566e92e6c8c2d88e2}} 
\index{antlr4\+::\+Rule\+Context@{antlr4\+::\+Rule\+Context}!set\+Alt\+Number@{set\+Alt\+Number}}
\index{set\+Alt\+Number@{set\+Alt\+Number}!antlr4\+::\+Rule\+Context@{antlr4\+::\+Rule\+Context}}
\subsubsection{\texorpdfstring{set\+Alt\+Number()}{setAltNumber()}}
{\footnotesize\ttfamily void Rule\+Context\+::set\+Alt\+Number (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{alt\+Number }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Set the outer alternative number for this context node. Default implementation does nothing to avoid backing field overhead for trees that don\textquotesingle{}t need it. Create a subclass of \hyperlink{classantlr4_1_1ParserRuleContext}{Parser\+Rule\+Context} with backing field and set option context\+Super\+Class.

\begin{DoxySince}{Since}
4.\+5.\+3 
\end{DoxySince}


Reimplemented in \hyperlink{classantlr4_1_1RuleContextWithAltNum_adf2d601a196a88f4f399ea5847f44151}{antlr4\+::\+Rule\+Context\+With\+Alt\+Num}.

\mbox{\Hypertarget{classantlr4_1_1RuleContext_ac4ba5cd65bf384baf9c27be9b14ebcfb}\label{classantlr4_1_1RuleContext_ac4ba5cd65bf384baf9c27be9b14ebcfb}} 
\index{antlr4\+::\+Rule\+Context@{antlr4\+::\+Rule\+Context}!to\+String\+Tree@{to\+String\+Tree}}
\index{to\+String\+Tree@{to\+String\+Tree}!antlr4\+::\+Rule\+Context@{antlr4\+::\+Rule\+Context}}
\subsubsection{\texorpdfstring{to\+String\+Tree()}{toStringTree()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::string Rule\+Context\+::to\+String\+Tree (\begin{DoxyParamCaption}\item[{\hyperlink{classantlr4_1_1Parser}{Parser} $\ast$}]{recog }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}



Print out a whole tree, not just a node, in L\+I\+SP format (root child1 .. childN). Print just a node if this is a leaf. We have to know the recognizer so we can get rule names. 

\mbox{\Hypertarget{classantlr4_1_1RuleContext_abcf82cbd07b59781b819a315a862c5a1}\label{classantlr4_1_1RuleContext_abcf82cbd07b59781b819a315a862c5a1}} 
\index{antlr4\+::\+Rule\+Context@{antlr4\+::\+Rule\+Context}!to\+String\+Tree@{to\+String\+Tree}}
\index{to\+String\+Tree@{to\+String\+Tree}!antlr4\+::\+Rule\+Context@{antlr4\+::\+Rule\+Context}}
\subsubsection{\texorpdfstring{to\+String\+Tree()}{toStringTree()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::string Rule\+Context\+::to\+String\+Tree (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::string $>$ \&}]{rule\+Names }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Print out a whole tree, not just a node, in L\+I\+SP format (root child1 .. childN). Print just a node if this is a leaf. 



\subsection{Member Data Documentation}
\mbox{\Hypertarget{classantlr4_1_1RuleContext_a2c4b8b84636c681f98dcd86d5c5a8459}\label{classantlr4_1_1RuleContext_a2c4b8b84636c681f98dcd86d5c5a8459}} 
\index{antlr4\+::\+Rule\+Context@{antlr4\+::\+Rule\+Context}!invoking\+State@{invoking\+State}}
\index{invoking\+State@{invoking\+State}!antlr4\+::\+Rule\+Context@{antlr4\+::\+Rule\+Context}}
\subsubsection{\texorpdfstring{invoking\+State}{invokingState}}
{\footnotesize\ttfamily size\+\_\+t antlr4\+::\+Rule\+Context\+::invoking\+State}

What state invoked the rule associated with this context? The \char`\"{}return address\char`\"{} is the follow\+State of invoking\+State If parent is null, this should be -\/1 and this context object represents the start rule. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
Rule\+Context.\+h\item 
Rule\+Context.\+cpp\end{DoxyCompactItemize}
