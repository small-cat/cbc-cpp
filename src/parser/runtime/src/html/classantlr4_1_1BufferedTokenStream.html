<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: antlr4::BufferedTokenStream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>antlr4</b></li><li class="navelem"><a class="el" href="classantlr4_1_1BufferedTokenStream.html">BufferedTokenStream</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classantlr4_1_1BufferedTokenStream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">antlr4::BufferedTokenStream Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="BufferedTokenStream_8h_source.html">BufferedTokenStream.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for antlr4::BufferedTokenStream:</div>
<div class="dyncontent">
<div class="center"><img src="classantlr4_1_1BufferedTokenStream__inherit__graph.png" border="0" usemap="#antlr4_1_1BufferedTokenStream_inherit__map" alt="Inheritance graph"/></div>
<map name="antlr4_1_1BufferedTokenStream_inherit__map" id="antlr4_1_1BufferedTokenStream_inherit__map">
<area shape="rect" id="node3" href="classantlr4_1_1CommonTokenStream.html" title="antlr4::CommonTokenStream" alt="" coords="5,155,199,181"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for antlr4::BufferedTokenStream:</div>
<div class="dyncontent">
<div class="center"><img src="classantlr4_1_1BufferedTokenStream__coll__graph.png" border="0" usemap="#antlr4_1_1BufferedTokenStream_coll__map" alt="Collaboration graph"/></div>
<map name="antlr4_1_1BufferedTokenStream_coll__map" id="antlr4_1_1BufferedTokenStream_coll__map">
<area shape="rect" id="node3" href="classantlr4_1_1TokenSource.html" title="A source of tokens must provide a sequence of tokens via nextToken(), CommonToken, CharStreamand also must reveal it&#39;s source of characters; &#39;s text is computed from a ; it only store indices into the char stream. Errors from the lexer are never passed to the parser. Either you want to keep going or you do not upon token recognition error. If you do not want to continue lexing then you do not want to continue parsing. Just throw an exception not under RecognitionExceptionand Java will naturally toss you all the way out of the recognizers. If you want to continue lexing then you should not throw an exception to the parserâ€“it has already requested a token. Keep lexing until you get a valid one. Just report errors and keep going, looking for a valid token. " alt="" coords="130,5,269,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8745b20dfdbda56d024d3bbd7b1b952b"><td class="memItemLeft" align="right" valign="top"><a id="a8745b20dfdbda56d024d3bbd7b1b952b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BufferedTokenStream</b> (<a class="el" href="classantlr4_1_1TokenSource.html">TokenSource</a> *tokenSource)</td></tr>
<tr class="separator:a8745b20dfdbda56d024d3bbd7b1b952b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80d128b76649cb544a2687392b455ba"><td class="memItemLeft" align="right" valign="top"><a id="aa80d128b76649cb544a2687392b455ba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BufferedTokenStream</b> (const <a class="el" href="classantlr4_1_1BufferedTokenStream.html">BufferedTokenStream</a> &amp;other)=delete</td></tr>
<tr class="separator:aa80d128b76649cb544a2687392b455ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a4c451709b72c3a1fc3b5e129a0589"><td class="memItemLeft" align="right" valign="top"><a id="aa3a4c451709b72c3a1fc3b5e129a0589"></a>
<a class="el" href="classantlr4_1_1BufferedTokenStream.html">BufferedTokenStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classantlr4_1_1BufferedTokenStream.html">BufferedTokenStream</a> &amp;other)=delete</td></tr>
<tr class="separator:aa3a4c451709b72c3a1fc3b5e129a0589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb641a7c1014a32c25a8de2161d980b"><td class="memItemLeft" align="right" valign="top"><a id="adfb641a7c1014a32c25a8de2161d980b"></a>
virtual <a class="el" href="classantlr4_1_1TokenSource.html">TokenSource</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getTokenSource</b> () const override</td></tr>
<tr class="separator:adfb641a7c1014a32c25a8de2161d980b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df0d36a9f48af46e957287d6f5242a5"><td class="memItemLeft" align="right" valign="top"><a id="a3df0d36a9f48af46e957287d6f5242a5"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>index</b> () override</td></tr>
<tr class="separator:a3df0d36a9f48af46e957287d6f5242a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ae6c5de3677e6836f162655c710a22"><td class="memItemLeft" align="right" valign="top"><a id="a04ae6c5de3677e6836f162655c710a22"></a>
virtual ssize_t&#160;</td><td class="memItemRight" valign="bottom"><b>mark</b> () override</td></tr>
<tr class="separator:a04ae6c5de3677e6836f162655c710a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af881ee9a58087055bc33c4d8ca2f64e7"><td class="memItemLeft" align="right" valign="top"><a id="af881ee9a58087055bc33c4d8ca2f64e7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>release</b> (ssize_t marker) override</td></tr>
<tr class="separator:af881ee9a58087055bc33c4d8ca2f64e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258dec8c7d9d2cf5ee0b69105cfab9e4"><td class="memItemLeft" align="right" valign="top"><a id="a258dec8c7d9d2cf5ee0b69105cfab9e4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> ()</td></tr>
<tr class="separator:a258dec8c7d9d2cf5ee0b69105cfab9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d113899cac110b51147147d9cb7b7a"><td class="memItemLeft" align="right" valign="top"><a id="a96d113899cac110b51147147d9cb7b7a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>seek</b> (size_t index) override</td></tr>
<tr class="separator:a96d113899cac110b51147147d9cb7b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacc9f5776ad27c0dde09daea4930952"><td class="memItemLeft" align="right" valign="top"><a id="abacc9f5776ad27c0dde09daea4930952"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () override</td></tr>
<tr class="separator:abacc9f5776ad27c0dde09daea4930952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f513618817ff1a02f4bd5f8bad57c7"><td class="memItemLeft" align="right" valign="top"><a id="a23f513618817ff1a02f4bd5f8bad57c7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>consume</b> () override</td></tr>
<tr class="separator:a23f513618817ff1a02f4bd5f8bad57c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409b9b2413d354d3e675f0e19ca80179"><td class="memItemLeft" align="right" valign="top"><a id="a409b9b2413d354d3e675f0e19ca80179"></a>
virtual <a class="el" href="classantlr4_1_1Token.html">Token</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get</b> (size_t i) const override</td></tr>
<tr class="separator:a409b9b2413d354d3e675f0e19ca80179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afaa76373aa65443db2f7d8c60a723c"><td class="memItemLeft" align="right" valign="top"><a id="a9afaa76373aa65443db2f7d8c60a723c"></a>
virtual std::vector&lt; <a class="el" href="classantlr4_1_1Token.html">Token</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1BufferedTokenStream.html#a9afaa76373aa65443db2f7d8c60a723c">get</a> (size_t start, size_t stop)</td></tr>
<tr class="memdesc:a9afaa76373aa65443db2f7d8c60a723c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all tokens from start..stop inclusively. <br /></td></tr>
<tr class="separator:a9afaa76373aa65443db2f7d8c60a723c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13d29ad96e08c0da1f0474faa035520"><td class="memItemLeft" align="right" valign="top"><a id="ac13d29ad96e08c0da1f0474faa035520"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>LA</b> (ssize_t i) override</td></tr>
<tr class="separator:ac13d29ad96e08c0da1f0474faa035520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f373d718e438523a5779941b96d7c01"><td class="memItemLeft" align="right" valign="top"><a id="a6f373d718e438523a5779941b96d7c01"></a>
virtual <a class="el" href="classantlr4_1_1Token.html">Token</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>LT</b> (ssize_t k) override</td></tr>
<tr class="separator:a6f373d718e438523a5779941b96d7c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3286f252ebc773cd6f4c1bd375e1012a"><td class="memItemLeft" align="right" valign="top"><a id="a3286f252ebc773cd6f4c1bd375e1012a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1BufferedTokenStream.html#a3286f252ebc773cd6f4c1bd375e1012a">setTokenSource</a> (<a class="el" href="classantlr4_1_1TokenSource.html">TokenSource</a> *tokenSource)</td></tr>
<tr class="memdesc:a3286f252ebc773cd6f4c1bd375e1012a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset this token stream by setting its token source. <br /></td></tr>
<tr class="separator:a3286f252ebc773cd6f4c1bd375e1012a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bfd7d726c911f192bae1eb6aeb571c"><td class="memItemLeft" align="right" valign="top"><a id="af6bfd7d726c911f192bae1eb6aeb571c"></a>
virtual std::vector&lt; <a class="el" href="classantlr4_1_1Token.html">Token</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getTokens</b> ()</td></tr>
<tr class="separator:af6bfd7d726c911f192bae1eb6aeb571c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2de27fefe90b711a500be49857c2da"><td class="memItemLeft" align="right" valign="top"><a id="a1a2de27fefe90b711a500be49857c2da"></a>
virtual std::vector&lt; <a class="el" href="classantlr4_1_1Token.html">Token</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getTokens</b> (size_t start, size_t stop)</td></tr>
<tr class="separator:a1a2de27fefe90b711a500be49857c2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da75f1766b2758b16be452bc1e06681"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classantlr4_1_1Token.html">Token</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1BufferedTokenStream.html#a1da75f1766b2758b16be452bc1e06681">getTokens</a> (size_t start, size_t stop, const std::vector&lt; size_t &gt; &amp;types)</td></tr>
<tr class="memdesc:a1da75f1766b2758b16be452bc1e06681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a start and stop index, return a List of all tokens in the token type BitSet. Return null if no tokens were found. This method looks at both on and off channel tokens.  <a href="#a1da75f1766b2758b16be452bc1e06681">More...</a><br /></td></tr>
<tr class="separator:a1da75f1766b2758b16be452bc1e06681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ddeab3509ccc606731b07a0c81725e"><td class="memItemLeft" align="right" valign="top"><a id="a18ddeab3509ccc606731b07a0c81725e"></a>
virtual std::vector&lt; <a class="el" href="classantlr4_1_1Token.html">Token</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getTokens</b> (size_t start, size_t stop, size_t ttype)</td></tr>
<tr class="separator:a18ddeab3509ccc606731b07a0c81725e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c260c6968178e322e5651ef0766925e"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classantlr4_1_1Token.html">Token</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1BufferedTokenStream.html#a6c260c6968178e322e5651ef0766925e">getHiddenTokensToRight</a> (size_t tokenIndex, ssize_t channel)</td></tr>
<tr class="separator:a6c260c6968178e322e5651ef0766925e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962f9c5cfb338e728948510a687174ec"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classantlr4_1_1Token.html">Token</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1BufferedTokenStream.html#a962f9c5cfb338e728948510a687174ec">getHiddenTokensToRight</a> (size_t tokenIndex)</td></tr>
<tr class="memdesc:a962f9c5cfb338e728948510a687174ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect all hidden tokens (any off-default channel) to the right of the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or EOF.  <a href="#a962f9c5cfb338e728948510a687174ec">More...</a><br /></td></tr>
<tr class="separator:a962f9c5cfb338e728948510a687174ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43a075d6f0ecbda219eef4a9e4633ee"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classantlr4_1_1Token.html">Token</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1BufferedTokenStream.html#ac43a075d6f0ecbda219eef4a9e4633ee">getHiddenTokensToLeft</a> (size_t tokenIndex, ssize_t channel)</td></tr>
<tr class="memdesc:ac43a075d6f0ecbda219eef4a9e4633ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect all tokens on specified channel to the left of the current token up until we see a token on DEFAULT_TOKEN_CHANNEL. If channel is -1, find any non default channel token.  <a href="#ac43a075d6f0ecbda219eef4a9e4633ee">More...</a><br /></td></tr>
<tr class="separator:ac43a075d6f0ecbda219eef4a9e4633ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f2ca68abd8075329bba1da12970493"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classantlr4_1_1Token.html">Token</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1BufferedTokenStream.html#aa6f2ca68abd8075329bba1da12970493">getHiddenTokensToLeft</a> (size_t tokenIndex)</td></tr>
<tr class="memdesc:aa6f2ca68abd8075329bba1da12970493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect all hidden tokens (any off-default channel) to the left of the current token up until we see a token on DEFAULT_TOKEN_CHANNEL.  <a href="#aa6f2ca68abd8075329bba1da12970493">More...</a><br /></td></tr>
<tr class="separator:aa6f2ca68abd8075329bba1da12970493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac623cc25ef85bed24d4a387bc6ad5663"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1BufferedTokenStream.html#ac623cc25ef85bed24d4a387bc6ad5663">getSourceName</a> () const override</td></tr>
<tr class="separator:ac623cc25ef85bed24d4a387bc6ad5663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a1573fe9be79daf42c793ebfe1abc6"><td class="memItemLeft" align="right" valign="top"><a id="ad7a1573fe9be79daf42c793ebfe1abc6"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getText</b> () override</td></tr>
<tr class="separator:ad7a1573fe9be79daf42c793ebfe1abc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330ddd9c7472b2fa9c59eb24ec1f4b94"><td class="memItemLeft" align="right" valign="top"><a id="a330ddd9c7472b2fa9c59eb24ec1f4b94"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getText</b> (const <a class="el" href="classantlr4_1_1misc_1_1Interval.html">misc::Interval</a> &amp;interval) override</td></tr>
<tr class="separator:a330ddd9c7472b2fa9c59eb24ec1f4b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9daa8586537ac66a8ad4152e26865199"><td class="memItemLeft" align="right" valign="top"><a id="a9daa8586537ac66a8ad4152e26865199"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getText</b> (<a class="el" href="classantlr4_1_1RuleContext.html">RuleContext</a> *ctx) override</td></tr>
<tr class="separator:a9daa8586537ac66a8ad4152e26865199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2090d846bb61a625a8ca23483571cebd"><td class="memItemLeft" align="right" valign="top"><a id="a2090d846bb61a625a8ca23483571cebd"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getText</b> (<a class="el" href="classantlr4_1_1Token.html">Token</a> *start, <a class="el" href="classantlr4_1_1Token.html">Token</a> *stop) override</td></tr>
<tr class="separator:a2090d846bb61a625a8ca23483571cebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373c27c4d4ec7358ba6985f4839e988a"><td class="memItemLeft" align="right" valign="top"><a id="a373c27c4d4ec7358ba6985f4839e988a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1BufferedTokenStream.html#a373c27c4d4ec7358ba6985f4839e988a">fill</a> ()</td></tr>
<tr class="memdesc:a373c27c4d4ec7358ba6985f4839e988a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all tokens from lexer until EOF. <br /></td></tr>
<tr class="separator:a373c27c4d4ec7358ba6985f4839e988a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa0a28e43e9e3329ddfe404804f726023"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classantlr4_1_1TokenSource.html">TokenSource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1BufferedTokenStream.html#aa0a28e43e9e3329ddfe404804f726023">_tokenSource</a></td></tr>
<tr class="separator:aa0a28e43e9e3329ddfe404804f726023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac681a8540466ec9aab6cff49bbcbdb4b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classantlr4_1_1Token.html">Token</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1BufferedTokenStream.html#ac681a8540466ec9aab6cff49bbcbdb4b">_tokens</a></td></tr>
<tr class="separator:ac681a8540466ec9aab6cff49bbcbdb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ab272f9ef3f5195ef8aeb4da15f9ca"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1BufferedTokenStream.html#aa8ab272f9ef3f5195ef8aeb4da15f9ca">_p</a></td></tr>
<tr class="separator:aa8ab272f9ef3f5195ef8aeb4da15f9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400797b54a3d7d151aa0ace27e766e8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1BufferedTokenStream.html#a400797b54a3d7d151aa0ace27e766e8e">_fetchedEOF</a></td></tr>
<tr class="separator:a400797b54a3d7d151aa0ace27e766e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This implementation of <a class="el" href="">TokenStream</a> loads tokens from a <a class="el" href="classantlr4_1_1TokenSource.html">TokenSource</a> on-demand, and places the tokens in a buffer to provide access to any previous token by index.</p>
<p>This token stream ignores the value of <a class="el" href="classantlr4_1_1Token.html#a92991c0566e4cb00ae2c5f9e7d8fe6b4">Token#getChannel</a>. If your parser requires the token stream filter tokens to only those on a particular channel, such as <a class="el" href="classantlr4_1_1Token.html#a699cbc56affbddc079561e175cba8435">Token#DEFAULT_CHANNEL</a> or <a class="el" href="classantlr4_1_1Token.html#af9bee187eba93f908d76d6406883424a">Token#HIDDEN_CHANNEL</a>, use a filtering token stream such a <a class="el" href="classantlr4_1_1CommonTokenStream.html">CommonTokenStream</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac43a075d6f0ecbda219eef4a9e4633ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43a075d6f0ecbda219eef4a9e4633ee">&#9670;&nbsp;</a></span>getHiddenTokensToLeft() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classantlr4_1_1Token.html">Token</a> * &gt; BufferedTokenStream::getHiddenTokensToLeft </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tokenIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collect all tokens on specified channel to the left of the current token up until we see a token on DEFAULT_TOKEN_CHANNEL. If channel is -1, find any non default channel token. </p>

</div>
</div>
<a id="aa6f2ca68abd8075329bba1da12970493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f2ca68abd8075329bba1da12970493">&#9670;&nbsp;</a></span>getHiddenTokensToLeft() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classantlr4_1_1Token.html">Token</a> * &gt; BufferedTokenStream::getHiddenTokensToLeft </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tokenIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collect all hidden tokens (any off-default channel) to the left of the current token up until we see a token on DEFAULT_TOKEN_CHANNEL. </p>

</div>
</div>
<a id="a6c260c6968178e322e5651ef0766925e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c260c6968178e322e5651ef0766925e">&#9670;&nbsp;</a></span>getHiddenTokensToRight() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classantlr4_1_1Token.html">Token</a> * &gt; BufferedTokenStream::getHiddenTokensToRight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tokenIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Collect all tokens on specified channel to the right of the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or EOF. If channel is -1, find any non default channel token. </p>

</div>
</div>
<a id="a962f9c5cfb338e728948510a687174ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962f9c5cfb338e728948510a687174ec">&#9670;&nbsp;</a></span>getHiddenTokensToRight() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classantlr4_1_1Token.html">Token</a> * &gt; BufferedTokenStream::getHiddenTokensToRight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tokenIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collect all hidden tokens (any off-default channel) to the right of the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or EOF. </p>

</div>
</div>
<a id="ac623cc25ef85bed24d4a387bc6ad5663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac623cc25ef85bed24d4a387bc6ad5663">&#9670;&nbsp;</a></span>getSourceName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string BufferedTokenStream::getSourceName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the text of all tokens in this buffer. </p>

</div>
</div>
<a id="a1da75f1766b2758b16be452bc1e06681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da75f1766b2758b16be452bc1e06681">&#9670;&nbsp;</a></span>getTokens()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classantlr4_1_1Token.html">Token</a> * &gt; BufferedTokenStream::getTokens </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a start and stop index, return a List of all tokens in the token type BitSet. Return null if no tokens were found. This method looks at both on and off channel tokens. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a400797b54a3d7d151aa0ace27e766e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400797b54a3d7d151aa0ace27e766e8e">&#9670;&nbsp;</a></span>_fetchedEOF</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool antlr4::BufferedTokenStream::_fetchedEOF</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicates whether the <a class="el" href="">Token#EOF</a> token has been fetched from <a class="el" href="">tokenSource</a> and added to <a class="el" href="">tokens</a>. This field improves performance for the following cases:</p>
<ul>
<li>
<a class="el" href="">consume</a>: The lookahead check in <a class="el" href="">consume</a> to prevent consuming the EOF symbol is optimized by checking the values of <a class="el" href="">fetchedEOF</a> and <a class="el" href="">p</a> instead of calling <a class="el" href="">LA</a>. </li>
<li>
<a class="el" href="">fetch</a>: The check to prevent adding multiple EOF symbols into <a class="el" href="">tokens</a> is trivial with this field. <ul>
<li>
</li>
</ul>
</li>
</ul>

</div>
</div>
<a id="aa8ab272f9ef3f5195ef8aeb4da15f9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ab272f9ef3f5195ef8aeb4da15f9ca">&#9670;&nbsp;</a></span>_p</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t antlr4::BufferedTokenStream::_p</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The index into <a class="el" href="">tokens</a> of the current token (next token to <a class="el" href="">consume</a>). <a class="el" href="">tokens</a></p><div class="fragment"><div class="line">[ </div></div><!-- fragment --><p> <a class="el" href="">p</a></p><div class="fragment"><div class="line">] </div></div><!-- fragment --><p> should be <a class="el" href="">LT(1)</a>.</p>
<p>This field is set to -1 when the stream is first constructed or when <a class="el" href="classantlr4_1_1BufferedTokenStream.html#a3286f252ebc773cd6f4c1bd375e1012a">setTokenSource</a> is called, indicating that the first token has not yet been fetched from the token source. For additional information, see the documentation of <a class="el" href="">IntStream</a> for a description of Initializing Methods.</p>

</div>
</div>
<a id="ac681a8540466ec9aab6cff49bbcbdb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac681a8540466ec9aab6cff49bbcbdb4b">&#9670;&nbsp;</a></span>_tokens</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::unique_ptr&lt;<a class="el" href="classantlr4_1_1Token.html">Token</a>&gt; &gt; antlr4::BufferedTokenStream::_tokens</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A collection of all tokens fetched from the token source. The list is considered a complete view of the input once <a class="el" href="">fetchedEOF</a> is set to</p><div class="fragment"><div class="line"><span class="keyword">true</span> </div></div><!-- fragment --><p> . </p>

</div>
</div>
<a id="aa0a28e43e9e3329ddfe404804f726023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a28e43e9e3329ddfe404804f726023">&#9670;&nbsp;</a></span>_tokenSource</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classantlr4_1_1TokenSource.html">TokenSource</a>* antlr4::BufferedTokenStream::_tokenSource</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <a class="el" href="classantlr4_1_1TokenSource.html">TokenSource</a> from which tokens for this stream are fetched. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="BufferedTokenStream_8h_source.html">BufferedTokenStream.h</a></li>
<li>BufferedTokenStream.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
