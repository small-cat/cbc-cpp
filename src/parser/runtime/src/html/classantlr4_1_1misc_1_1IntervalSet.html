<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: antlr4::misc::IntervalSet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>antlr4</b></li><li class="navelem"><b>misc</b></li><li class="navelem"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classantlr4_1_1misc_1_1IntervalSet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">antlr4::misc::IntervalSet Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="IntervalSet_8h_source.html">IntervalSet.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for antlr4::misc::IntervalSet:</div>
<div class="dyncontent">
<div class="center"><img src="classantlr4_1_1misc_1_1IntervalSet__coll__graph.png" border="0" usemap="#antlr4_1_1misc_1_1IntervalSet_coll__map" alt="Collaboration graph"/></div>
<map name="antlr4_1_1misc_1_1IntervalSet_coll__map" id="antlr4_1_1misc_1_1IntervalSet_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab321bbad8af15b8ad4b37c1562b675a6"><td class="memItemLeft" align="right" valign="top"><a id="ab321bbad8af15b8ad4b37c1562b675a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>IntervalSet</b> (<a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> const &amp;set)</td></tr>
<tr class="separator:ab321bbad8af15b8ad4b37c1562b675a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4301930f887a53963f7914c0eead97"><td class="memItemLeft" align="right" valign="top"><a id="acf4301930f887a53963f7914c0eead97"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>IntervalSet</b> (<a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> &amp;&amp;set)</td></tr>
<tr class="separator:acf4301930f887a53963f7914c0eead97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1b9139afcfd82ff46c586ed4fd96d5"><td class="memTemplParams" colspan="2"><a id="a9f1b9139afcfd82ff46c586ed4fd96d5"></a>
template&lt;typename T1 , typename... T_NEXT&gt; </td></tr>
<tr class="memitem:a9f1b9139afcfd82ff46c586ed4fd96d5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IntervalSet</b> (int, T1 t1, T_NEXT &amp;&amp;... next)</td></tr>
<tr class="separator:a9f1b9139afcfd82ff46c586ed4fd96d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdafeb29f314fadf9832c61d33a55662"><td class="memItemLeft" align="right" valign="top"><a id="abdafeb29f314fadf9832c61d33a55662"></a>
<a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> const &amp;set)</td></tr>
<tr class="separator:abdafeb29f314fadf9832c61d33a55662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98983e9c22da6cdb3ab47e95d76550f"><td class="memItemLeft" align="right" valign="top"><a id="ab98983e9c22da6cdb3ab47e95d76550f"></a>
<a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> &amp;&amp;set)</td></tr>
<tr class="separator:ab98983e9c22da6cdb3ab47e95d76550f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d89c38e3bde61406db9b8165f8ce58"><td class="memItemLeft" align="right" valign="top"><a id="a09d89c38e3bde61406db9b8165f8ce58"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:a09d89c38e3bde61406db9b8165f8ce58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e72d626d99ce3cc0b7f4d0a973aec4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html#ad8e72d626d99ce3cc0b7f4d0a973aec4">add</a> (ssize_t el)</td></tr>
<tr class="separator:ad8e72d626d99ce3cc0b7f4d0a973aec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b86051dddc4528980ae54202c58c2ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html#a4b86051dddc4528980ae54202c58c2ef">add</a> (ssize_t a, ssize_t b)</td></tr>
<tr class="separator:a4b86051dddc4528980ae54202c58c2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d503743162defae29f96405b55f2a27"><td class="memItemLeft" align="right" valign="top"><a id="a7d503743162defae29f96405b55f2a27"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add</b> (const <a class="el" href="classantlr4_1_1misc_1_1Interval.html">Interval</a> &amp;addition)</td></tr>
<tr class="separator:a7d503743162defae29f96405b55f2a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892464253b5fcf743091ba4a94dc4622"><td class="memItemLeft" align="right" valign="top"><a id="a892464253b5fcf743091ba4a94dc4622"></a>
<a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>addAll</b> (const <a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> &amp;set)</td></tr>
<tr class="separator:a892464253b5fcf743091ba4a94dc4622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c01dec9ec1f6bc4f63aa3246a38103a"><td class="memTemplParams" colspan="2"><a id="a2c01dec9ec1f6bc4f63aa3246a38103a"></a>
template&lt;typename T1 , typename... T_NEXT&gt; </td></tr>
<tr class="memitem:a2c01dec9ec1f6bc4f63aa3246a38103a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addItems</b> (T1 t1, T_NEXT &amp;&amp;... next)</td></tr>
<tr class="separator:a2c01dec9ec1f6bc4f63aa3246a38103a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ee1cc2b279df1c451e99328370d274"><td class="memItemLeft" align="right" valign="top"><a id="a48ee1cc2b279df1c451e99328370d274"></a>
<a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>complement</b> (ssize_t minElement, ssize_t maxElement) const</td></tr>
<tr class="separator:a48ee1cc2b279df1c451e99328370d274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abb367611d1797657ae64247403f4e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html#a8abb367611d1797657ae64247403f4e2">complement</a> (const <a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> &amp;vocabulary) const</td></tr>
<tr class="separator:a8abb367611d1797657ae64247403f4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21b25a3093c1b6173141a89319589fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html#ab21b25a3093c1b6173141a89319589fa">subtract</a> (const <a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> &amp;other) const</td></tr>
<tr class="separator:ab21b25a3093c1b6173141a89319589fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b29c1a77e98907618e1820ff185362d"><td class="memItemLeft" align="right" valign="top"><a id="a5b29c1a77e98907618e1820ff185362d"></a>
<a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Or</b> (const <a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> &amp;a) const</td></tr>
<tr class="separator:a5b29c1a77e98907618e1820ff185362d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181657a8554e9836bd2dc7c9be0a02f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html#a181657a8554e9836bd2dc7c9be0a02f0">And</a> (const <a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> &amp;other) const</td></tr>
<tr class="separator:a181657a8554e9836bd2dc7c9be0a02f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45ff96376a2cd90fa0b72ea32decaf9"><td class="memItemLeft" align="right" valign="top"><a id="ae45ff96376a2cd90fa0b72ea32decaf9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html#ae45ff96376a2cd90fa0b72ea32decaf9">contains</a> (size_t el) const</td></tr>
<tr class="memdesc:ae45ff96376a2cd90fa0b72ea32decaf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is el in any range of this set? <br /></td></tr>
<tr class="separator:ae45ff96376a2cd90fa0b72ea32decaf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6488f45c958dce6899759db3dae57d"><td class="memItemLeft" align="right" valign="top"><a id="afc6488f45c958dce6899759db3dae57d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (ssize_t el) const</td></tr>
<tr class="separator:afc6488f45c958dce6899759db3dae57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e95d772d8c02588ec690754e25d669f"><td class="memItemLeft" align="right" valign="top"><a id="a8e95d772d8c02588ec690754e25d669f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html#a8e95d772d8c02588ec690754e25d669f">isEmpty</a> () const</td></tr>
<tr class="memdesc:a8e95d772d8c02588ec690754e25d669f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if this set has no members <br /></td></tr>
<tr class="separator:a8e95d772d8c02588ec690754e25d669f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f90e3fc52eac6d52cb693d00c94e7f6"><td class="memItemLeft" align="right" valign="top"><a id="a9f90e3fc52eac6d52cb693d00c94e7f6"></a>
ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html#a9f90e3fc52eac6d52cb693d00c94e7f6">getSingleElement</a> () const</td></tr>
<tr class="memdesc:a9f90e3fc52eac6d52cb693d00c94e7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this set is a single integer, return it otherwise Token.INVALID_TYPE. <br /></td></tr>
<tr class="separator:a9f90e3fc52eac6d52cb693d00c94e7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f95bbd9eef0e87e637600c60ca65a6f"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html#a6f95bbd9eef0e87e637600c60ca65a6f">getMaxElement</a> () const</td></tr>
<tr class="separator:a6f95bbd9eef0e87e637600c60ca65a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56d5b4e2b0d420e15cfc33f2cbeec6e"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html#ac56d5b4e2b0d420e15cfc33f2cbeec6e">getMinElement</a> () const</td></tr>
<tr class="separator:ac56d5b4e2b0d420e15cfc33f2cbeec6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f5e60d4c0a59d259fed37e24ff96bc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classantlr4_1_1misc_1_1Interval.html">Interval</a> &gt; const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html#ae0f5e60d4c0a59d259fed37e24ff96bc">getIntervals</a> () const</td></tr>
<tr class="memdesc:ae0f5e60d4c0a59d259fed37e24ff96bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of <a class="el" href="classantlr4_1_1misc_1_1Interval.html" title="An immutable inclusive interval a..b. ">Interval</a> objects.  <a href="#ae0f5e60d4c0a59d259fed37e24ff96bc">More...</a><br /></td></tr>
<tr class="separator:ae0f5e60d4c0a59d259fed37e24ff96bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad88eb36ed05f285f0871982070a8fa7"><td class="memItemLeft" align="right" valign="top"><a id="aad88eb36ed05f285f0871982070a8fa7"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>hashCode</b> () const</td></tr>
<tr class="separator:aad88eb36ed05f285f0871982070a8fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ad0522ad659ed9b80d16ada050390c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html#a47ad0522ad659ed9b80d16ada050390c">operator==</a> (const <a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> &amp;other) const</td></tr>
<tr class="separator:a47ad0522ad659ed9b80d16ada050390c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad8fd554f7cf35c896287e7e2be1e63"><td class="memItemLeft" align="right" valign="top"><a id="a8ad8fd554f7cf35c896287e7e2be1e63"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> () const</td></tr>
<tr class="separator:a8ad8fd554f7cf35c896287e7e2be1e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43c9223eb4175c1ef49cd770555142b"><td class="memItemLeft" align="right" valign="top"><a id="ae43c9223eb4175c1ef49cd770555142b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (bool elemAreChar) const</td></tr>
<tr class="separator:ae43c9223eb4175c1ef49cd770555142b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1798065f0f309e559c6c6efc07b6b1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html#aca1798065f0f309e559c6c6efc07b6b1">toString</a> (const std::vector&lt; std::string &gt; &amp;tokenNames) const</td></tr>
<tr class="separator:aca1798065f0f309e559c6c6efc07b6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760e5bff7db3cc0d1a14db3c6cd43de8"><td class="memItemLeft" align="right" valign="top"><a id="a760e5bff7db3cc0d1a14db3c6cd43de8"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (const dfa::Vocabulary &amp;vocabulary) const</td></tr>
<tr class="separator:a760e5bff7db3cc0d1a14db3c6cd43de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5586fbe7a38bb76ce570b770c44a07a1"><td class="memItemLeft" align="right" valign="top"><a id="a5586fbe7a38bb76ce570b770c44a07a1"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="separator:a5586fbe7a38bb76ce570b770c44a07a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bd9a3eba25401ded890f4c0aefb152"><td class="memItemLeft" align="right" valign="top"><a id="af9bd9a3eba25401ded890f4c0aefb152"></a>
std::vector&lt; ssize_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>toList</b> () const</td></tr>
<tr class="separator:af9bd9a3eba25401ded890f4c0aefb152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18229c7c3e238e561e3ef0aef98ceefb"><td class="memItemLeft" align="right" valign="top"><a id="a18229c7c3e238e561e3ef0aef98ceefb"></a>
std::set&lt; ssize_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>toSet</b> () const</td></tr>
<tr class="separator:a18229c7c3e238e561e3ef0aef98ceefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e9df51ea033526f7efd519841da32e"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html#a71e9df51ea033526f7efd519841da32e">get</a> (size_t i) const</td></tr>
<tr class="separator:a71e9df51ea033526f7efd519841da32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da04b62224782f63599594039b4379a"><td class="memItemLeft" align="right" valign="top"><a id="a3da04b62224782f63599594039b4379a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>remove</b> (size_t el)</td></tr>
<tr class="separator:a3da04b62224782f63599594039b4379a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af27c35f8a90179f41d7db9bf3d00d4"><td class="memItemLeft" align="right" valign="top"><a id="a0af27c35f8a90179f41d7db9bf3d00d4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>remove</b> (ssize_t el)</td></tr>
<tr class="separator:a0af27c35f8a90179f41d7db9bf3d00d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad7b2791799066867e684ab8a69b78fb7"><td class="memItemLeft" align="right" valign="top"><a id="ad7b2791799066867e684ab8a69b78fb7"></a>
static <a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html#ad7b2791799066867e684ab8a69b78fb7">of</a> (ssize_t a)</td></tr>
<tr class="memdesc:ad7b2791799066867e684ab8a69b78fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a set with a single element, el. <br /></td></tr>
<tr class="separator:ad7b2791799066867e684ab8a69b78fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2472831ec5ecc186d1415a76a8c58c"><td class="memItemLeft" align="right" valign="top"><a id="aab2472831ec5ecc186d1415a76a8c58c"></a>
static <a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html#aab2472831ec5ecc186d1415a76a8c58c">of</a> (ssize_t a, ssize_t b)</td></tr>
<tr class="memdesc:aab2472831ec5ecc186d1415a76a8c58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a set with all ints within range [a..b] (inclusive) <br /></td></tr>
<tr class="separator:aab2472831ec5ecc186d1415a76a8c58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd2239e963d2d7913f4c7fd17d8afb0"><td class="memItemLeft" align="right" valign="top"><a id="acdd2239e963d2d7913f4c7fd17d8afb0"></a>
static <a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html#acdd2239e963d2d7913f4c7fd17d8afb0">Or</a> (const std::vector&lt; <a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> &gt; &amp;sets)</td></tr>
<tr class="memdesc:acdd2239e963d2d7913f4c7fd17d8afb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">combine all sets in the array returned the or'd value <br /></td></tr>
<tr class="separator:acdd2239e963d2d7913f4c7fd17d8afb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3f30153b722dd4ce77325305b6470a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html#a1a3f30153b722dd4ce77325305b6470a">subtract</a> (const <a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> &amp;left, const <a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> &amp;right)</td></tr>
<tr class="separator:a1a3f30153b722dd4ce77325305b6470a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a9ca1324ca4b7f1c69ffe44f0b3f14bca"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> const&#160;</td><td class="memItemRight" valign="bottom"><b>COMPLETE_CHAR_SET</b></td></tr>
<tr class="separator:a9ca1324ca4b7f1c69ffe44f0b3f14bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdf62c1c0de87491c5044a42c6adfcd"><td class="memItemLeft" align="right" valign="top"><a id="a7bdf62c1c0de87491c5044a42c6adfcd"></a>
static <a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> const&#160;</td><td class="memItemRight" valign="bottom"><b>EMPTY_SET</b></td></tr>
<tr class="separator:a7bdf62c1c0de87491c5044a42c6adfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a10334d09c666f59ced45f43b9cd2772a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html#a10334d09c666f59ced45f43b9cd2772a">elementName</a> (const std::vector&lt; std::string &gt; &amp;tokenNames, ssize_t a) const</td></tr>
<tr class="separator:a10334d09c666f59ced45f43b9cd2772a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996d85ad96aa8f7f38a394ee6c340fc5"><td class="memItemLeft" align="right" valign="top"><a id="a996d85ad96aa8f7f38a394ee6c340fc5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>elementName</b> (const dfa::Vocabulary &amp;vocabulary, ssize_t a) const</td></tr>
<tr class="separator:a996d85ad96aa8f7f38a394ee6c340fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements the <a class="el" href="">IntSet</a> backed by a sorted array of non-overlapping intervals. It is particularly efficient for representing large collections of numbers, where the majority of elements appear as part of a sequential range of numbers that are all part of the set. For example, the set { 1, 2, 3, 4, 7, 8 } may be represented as { [1, 4], [7, 8] }.</p>
<p>This class is able to represent sets containing any combination of values in the range <a class="el" href="">Integer#MIN_VALUE</a> to <a class="el" href="">Integer#MAX_VALUE</a> (inclusive).</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad8e72d626d99ce3cc0b7f4d0a973aec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e72d626d99ce3cc0b7f4d0a973aec4">&#9670;&nbsp;</a></span>add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntervalSet::add </td>
          <td>(</td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a single element to the set. An isolated element is stored as a range el..el. </p>

</div>
</div>
<a id="a4b86051dddc4528980ae54202c58c2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b86051dddc4528980ae54202c58c2ef">&#9670;&nbsp;</a></span>add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IntervalSet::add </td>
          <td>(</td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add interval; i.e., add all integers from a to b to set. If b&lt;a, do nothing. Keep list in sorted order (by left range value). If overlap, combine ranges. For example, If this is {1..5, 10..20}, adding 6..7 yields {1..5, 6..7, 10..20}. Adding 4..8 yields {1..8, 10..20}. </p>

</div>
</div>
<a id="a181657a8554e9836bd2dc7c9be0a02f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181657a8554e9836bd2dc7c9be0a02f0">&#9670;&nbsp;</a></span>And()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> IntervalSet::And </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a new set with the intersection of this set with other. Because the intervals are sorted, we can use an iterator for each list and just walk them together. This is roughly O(min(n,m)) for interval list lengths n and m. </p>

</div>
</div>
<a id="a8abb367611d1797657ae64247403f4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8abb367611d1797657ae64247403f4e2">&#9670;&nbsp;</a></span>complement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> IntervalSet::complement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> &amp;&#160;</td>
          <td class="paramname"><em>vocabulary</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the set of possible values (rather than, say UNICODE or MAXINT), return a new set containing all elements in vocabulary, but not in this. The computation is (vocabulary - this).</p>
<p>'this' is assumed to be either a subset or equal to vocabulary. </p>

</div>
</div>
<a id="a10334d09c666f59ced45f43b9cd2772a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10334d09c666f59ced45f43b9cd2772a">&#9670;&nbsp;</a></span>elementName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string IntervalSet::elementName </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>tokenNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>Use <a class="el" href="">elementName(Vocabulary, int)</a> instead. </dd></dl>

</div>
</div>
<a id="a71e9df51ea033526f7efd519841da32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e9df51ea033526f7efd519841da32e">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t IntervalSet::get </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the ith element of ordered set. Used only by RandomPhrase so don't bother to implement if you're not doing that for a new ANTLR code gen target. </p>

</div>
</div>
<a id="ae0f5e60d4c0a59d259fed37e24ff96bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f5e60d4c0a59d259fed37e24ff96bc">&#9670;&nbsp;</a></span>getIntervals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classantlr4_1_1misc_1_1Interval.html">Interval</a> &gt; const  &amp; IntervalSet::getIntervals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of <a class="el" href="classantlr4_1_1misc_1_1Interval.html" title="An immutable inclusive interval a..b. ">Interval</a> objects. </p>

</div>
</div>
<a id="a6f95bbd9eef0e87e637600c60ca65a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f95bbd9eef0e87e637600c60ca65a6f">&#9670;&nbsp;</a></span>getMaxElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t IntervalSet::getMaxElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the maximum value contained in the set.</p>
<dl class="section return"><dt>Returns</dt><dd>the maximum value contained in the set. If the set is empty, this method returns <a class="el" href="">Token#INVALID_TYPE</a>. </dd></dl>

</div>
</div>
<a id="ac56d5b4e2b0d420e15cfc33f2cbeec6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56d5b4e2b0d420e15cfc33f2cbeec6e">&#9670;&nbsp;</a></span>getMinElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t IntervalSet::getMinElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the minimum value contained in the set.</p>
<dl class="section return"><dt>Returns</dt><dd>the minimum value contained in the set. If the set is empty, this method returns <a class="el" href="">Token#INVALID_TYPE</a>. </dd></dl>

</div>
</div>
<a id="a47ad0522ad659ed9b80d16ada050390c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ad0522ad659ed9b80d16ada050390c">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IntervalSet::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Are two IntervalSets equal? Because all intervals are sorted and disjoint, equals is a simple linear walk over both lists to make sure they are the same. </p>

</div>
</div>
<a id="ab21b25a3093c1b6173141a89319589fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21b25a3093c1b6173141a89319589fa">&#9670;&nbsp;</a></span>subtract() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> IntervalSet::subtract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute this-other via this&amp;~other. Return a new set containing all elements in this but not in other. other is assumed to be a subset of this; anything that is in other but not in this will be ignored. </p>

</div>
</div>
<a id="a1a3f30153b722dd4ce77325305b6470a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3f30153b722dd4ce77325305b6470a">&#9670;&nbsp;</a></span>subtract() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> IntervalSet::subtract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the set difference between two interval sets. The specific operation is</p><div class="fragment"><div class="line">left - right </div></div><!-- fragment --><p> . If either of the input sets is </p><div class="fragment"><div class="line">null </div></div><!-- fragment --><p> , it is treated as though it was an empty set. </p>

</div>
</div>
<a id="aca1798065f0f309e559c6c6efc07b6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1798065f0f309e559c6c6efc07b6b1">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string IntervalSet::toString </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>tokenNames</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>Use <a class="el" href="">toString(Vocabulary)</a> instead. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9ca1324ca4b7f1c69ffe44f0b3f14bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca1324ca4b7f1c69ffe44f0b3f14bca">&#9670;&nbsp;</a></span>COMPLETE_CHAR_SET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classantlr4_1_1misc_1_1IntervalSet.html">IntervalSet</a> const IntervalSet::COMPLETE_CHAR_SET</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= </div><div class="line">    <a class="code" href="classantlr4_1_1misc_1_1IntervalSet.html#ad7b2791799066867e684ab8a69b78fb7">IntervalSet::of</a>(Lexer::MIN_CHAR_VALUE, Lexer::MAX_CHAR_VALUE)</div></div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>misc/<a class="el" href="IntervalSet_8h_source.html">IntervalSet.h</a></li>
<li>misc/IntervalSet.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
