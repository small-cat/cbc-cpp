<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: antlr4::ParserRuleContext Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>antlr4</b></li><li class="navelem"><a class="el" href="classantlr4_1_1ParserRuleContext.html">ParserRuleContext</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classantlr4_1_1ParserRuleContext-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">antlr4::ParserRuleContext Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A rule invocation record for parsing.  
 <a href="classantlr4_1_1ParserRuleContext.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ParserRuleContext_8h_source.html">ParserRuleContext.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for antlr4::ParserRuleContext:</div>
<div class="dyncontent">
<div class="center"><img src="classantlr4_1_1ParserRuleContext__inherit__graph.png" border="0" usemap="#antlr4_1_1ParserRuleContext_inherit__map" alt="Inheritance graph"/></div>
<map name="antlr4_1_1ParserRuleContext_inherit__map" id="antlr4_1_1ParserRuleContext_inherit__map">
<area shape="rect" id="node4" href="classantlr4_1_1InterpreterRuleContext.html" title="antlr4::InterpreterRuleContext" alt="" coords="5,229,200,256"/>
<area shape="rect" id="node5" href="classantlr4_1_1RuleContextWithAltNum.html" title="antlr4::RuleContextWithAltNum" alt="" coords="225,229,431,256"/>
<area shape="rect" id="node2" href="classantlr4_1_1RuleContext.html" title="antlr4::RuleContext" alt="" coords="147,80,282,107"/>
<area shape="rect" id="node3" href="classantlr4_1_1tree_1_1ParseTree.html" title="antlr4::tree::ParseTree" alt="" coords="139,5,291,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for antlr4::ParserRuleContext:</div>
<div class="dyncontent">
<div class="center"><img src="classantlr4_1_1ParserRuleContext__coll__graph.png" border="0" usemap="#antlr4_1_1ParserRuleContext_coll__map" alt="Collaboration graph"/></div>
<map name="antlr4_1_1ParserRuleContext_coll__map" id="antlr4_1_1ParserRuleContext_coll__map">
<area shape="rect" id="node2" href="classantlr4_1_1RuleContext.html" title="antlr4::RuleContext" alt="" coords="14,81,149,108"/>
<area shape="rect" id="node3" href="classantlr4_1_1tree_1_1ParseTree.html" title="antlr4::tree::ParseTree" alt="" coords="5,5,157,32"/>
<area shape="rect" id="node4" href="classantlr4_1_1Token.html" title="antlr4::Token" alt="" coords="173,81,272,108"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a13e9a86b7d2ccb34c2d50550deb4b36d"><td class="memItemLeft" align="right" valign="top"><a id="a13e9a86b7d2ccb34c2d50550deb4b36d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ParserRuleContext</b> (<a class="el" href="classantlr4_1_1ParserRuleContext.html">ParserRuleContext</a> *<a class="el" href="classantlr4_1_1tree_1_1ParseTree.html#a83402632670316b68280c04e6be70d50">parent</a>, size_t invokingStateNumber)</td></tr>
<tr class="separator:a13e9a86b7d2ccb34c2d50550deb4b36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e160f0c98a6475424ffe193040cdae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1ParserRuleContext.html#a32e160f0c98a6475424ffe193040cdae">copyFrom</a> (<a class="el" href="classantlr4_1_1ParserRuleContext.html">ParserRuleContext</a> *ctx)</td></tr>
<tr class="separator:a32e160f0c98a6475424ffe193040cdae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee63c438f6be836d5592cf1f045c735f"><td class="memItemLeft" align="right" valign="top"><a id="aee63c438f6be836d5592cf1f045c735f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>enterRule</b> (<a class="el" href="classantlr4_1_1tree_1_1ParseTreeListener.html">tree::ParseTreeListener</a> *listener)</td></tr>
<tr class="separator:aee63c438f6be836d5592cf1f045c735f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd661fddddc4e72900091d23f6c81afe"><td class="memItemLeft" align="right" valign="top"><a id="acd661fddddc4e72900091d23f6c81afe"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>exitRule</b> (<a class="el" href="classantlr4_1_1tree_1_1ParseTreeListener.html">tree::ParseTreeListener</a> *listener)</td></tr>
<tr class="separator:acd661fddddc4e72900091d23f6c81afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402addbef275358076e63253db77b0c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classantlr4_1_1tree_1_1TerminalNode.html">tree::TerminalNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1ParserRuleContext.html#a402addbef275358076e63253db77b0c4">addChild</a> (<a class="el" href="classantlr4_1_1tree_1_1TerminalNode.html">tree::TerminalNode</a> *t)</td></tr>
<tr class="separator:a402addbef275358076e63253db77b0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31addd41aee593b86d5e15c243c084e"><td class="memItemLeft" align="right" valign="top"><a id="ab31addd41aee593b86d5e15c243c084e"></a>
<a class="el" href="classantlr4_1_1RuleContext.html">RuleContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>addChild</b> (<a class="el" href="classantlr4_1_1RuleContext.html">RuleContext</a> *ruleInvocation)</td></tr>
<tr class="separator:ab31addd41aee593b86d5e15c243c084e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7e71fc8e12b036014820a1d530b8bb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1ParserRuleContext.html#a0d7e71fc8e12b036014820a1d530b8bb">removeLastChild</a> ()</td></tr>
<tr class="separator:a0d7e71fc8e12b036014820a1d530b8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7888fb2f93de0a8d68101192a1eb51"><td class="memItemLeft" align="right" valign="top"><a id="a7c7888fb2f93de0a8d68101192a1eb51"></a>
virtual <a class="el" href="classantlr4_1_1tree_1_1TerminalNode.html">tree::TerminalNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getToken</b> (size_t ttype, std::size_t i)</td></tr>
<tr class="separator:a7c7888fb2f93de0a8d68101192a1eb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642538341e37d3391db1ad558cbb30ab"><td class="memItemLeft" align="right" valign="top"><a id="a642538341e37d3391db1ad558cbb30ab"></a>
virtual std::vector&lt; <a class="el" href="classantlr4_1_1tree_1_1TerminalNode.html">tree::TerminalNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getTokens</b> (size_t ttype)</td></tr>
<tr class="separator:a642538341e37d3391db1ad558cbb30ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6556b9859491c8b0ff166af71218e2d5"><td class="memTemplParams" colspan="2"><a id="a6556b9859491c8b0ff166af71218e2d5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6556b9859491c8b0ff166af71218e2d5"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getRuleContext</b> (size_t i)</td></tr>
<tr class="separator:a6556b9859491c8b0ff166af71218e2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e62d59955f25f81d6b0d79111a9fab7"><td class="memTemplParams" colspan="2"><a id="a3e62d59955f25f81d6b0d79111a9fab7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3e62d59955f25f81d6b0d79111a9fab7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getRuleContexts</b> ()</td></tr>
<tr class="separator:a3e62d59955f25f81d6b0d79111a9fab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1858e04ce2a478986ded6dced62dc4"><td class="memItemLeft" align="right" valign="top"><a id="a8d1858e04ce2a478986ded6dced62dc4"></a>
virtual <a class="el" href="classantlr4_1_1misc_1_1Interval.html">misc::Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getSourceInterval</b> () override</td></tr>
<tr class="separator:a8d1858e04ce2a478986ded6dced62dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069cff86aad00ea0618985e78291e8fa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classantlr4_1_1Token.html">Token</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1ParserRuleContext.html#a069cff86aad00ea0618985e78291e8fa">getStart</a> ()</td></tr>
<tr class="separator:a069cff86aad00ea0618985e78291e8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51432e71c46225602c504768c50ad776"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classantlr4_1_1Token.html">Token</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1ParserRuleContext.html#a51432e71c46225602c504768c50ad776">getStop</a> ()</td></tr>
<tr class="separator:a51432e71c46225602c504768c50ad776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fdb4f19d0b2dce76164b3ffee6d81e"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1ParserRuleContext.html#a36fdb4f19d0b2dce76164b3ffee6d81e">toInfoString</a> (<a class="el" href="classantlr4_1_1Parser.html">Parser</a> *recognizer)</td></tr>
<tr class="memdesc:a36fdb4f19d0b2dce76164b3ffee6d81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for rule context info debugging during parse-time, not so much for ATN debugging  <a href="#a36fdb4f19d0b2dce76164b3ffee6d81e">More...</a><br /></td></tr>
<tr class="separator:a36fdb4f19d0b2dce76164b3ffee6d81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classantlr4_1_1RuleContext"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classantlr4_1_1RuleContext')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classantlr4_1_1RuleContext.html">antlr4::RuleContext</a></td></tr>
<tr class="memitem:a3a8366fbdf9e4782e0770cafe361ef4d inherit pub_methods_classantlr4_1_1RuleContext"><td class="memItemLeft" align="right" valign="top"><a id="a3a8366fbdf9e4782e0770cafe361ef4d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>RuleContext</b> (<a class="el" href="classantlr4_1_1RuleContext.html">RuleContext</a> *<a class="el" href="classantlr4_1_1tree_1_1ParseTree.html#a83402632670316b68280c04e6be70d50">parent</a>, size_t <a class="el" href="classantlr4_1_1RuleContext.html#a2c4b8b84636c681f98dcd86d5c5a8459">invokingState</a>)</td></tr>
<tr class="separator:a3a8366fbdf9e4782e0770cafe361ef4d inherit pub_methods_classantlr4_1_1RuleContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b5f07f832e628025b22bd1554c239c inherit pub_methods_classantlr4_1_1RuleContext"><td class="memItemLeft" align="right" valign="top"><a id="a84b5f07f832e628025b22bd1554c239c"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>depth</b> ()</td></tr>
<tr class="separator:a84b5f07f832e628025b22bd1554c239c inherit pub_methods_classantlr4_1_1RuleContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b85b3df53a724a0a3cc2b8bc949045e inherit pub_methods_classantlr4_1_1RuleContext"><td class="memItemLeft" align="right" valign="top"><a id="a9b85b3df53a724a0a3cc2b8bc949045e"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1RuleContext.html#a9b85b3df53a724a0a3cc2b8bc949045e">isEmpty</a> ()</td></tr>
<tr class="memdesc:a9b85b3df53a724a0a3cc2b8bc949045e inherit pub_methods_classantlr4_1_1RuleContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">A context is empty if there is no invoking state; meaning nobody called current context. <br /></td></tr>
<tr class="separator:a9b85b3df53a724a0a3cc2b8bc949045e inherit pub_methods_classantlr4_1_1RuleContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33302ceb47c02e06e24beffac9b8564e inherit pub_methods_classantlr4_1_1RuleContext"><td class="memItemLeft" align="right" valign="top"><a id="a33302ceb47c02e06e24beffac9b8564e"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getText</b> () override</td></tr>
<tr class="separator:a33302ceb47c02e06e24beffac9b8564e inherit pub_methods_classantlr4_1_1RuleContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c47d330254d4224073408522ac6956 inherit pub_methods_classantlr4_1_1RuleContext"><td class="memItemLeft" align="right" valign="top"><a id="ab3c47d330254d4224073408522ac6956"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getRuleIndex</b> () const</td></tr>
<tr class="separator:ab3c47d330254d4224073408522ac6956 inherit pub_methods_classantlr4_1_1RuleContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb31efff7ed16c524298b9052c75e8f7 inherit pub_methods_classantlr4_1_1RuleContext"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1RuleContext.html#abb31efff7ed16c524298b9052c75e8f7">getAltNumber</a> () const</td></tr>
<tr class="separator:abb31efff7ed16c524298b9052c75e8f7 inherit pub_methods_classantlr4_1_1RuleContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13942e9b3fc17ab566e92e6c8c2d88e2 inherit pub_methods_classantlr4_1_1RuleContext"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1RuleContext.html#a13942e9b3fc17ab566e92e6c8c2d88e2">setAltNumber</a> (size_t altNumber)</td></tr>
<tr class="separator:a13942e9b3fc17ab566e92e6c8c2d88e2 inherit pub_methods_classantlr4_1_1RuleContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8188a57118653c6dcba7de466e572bfd inherit pub_methods_classantlr4_1_1RuleContext"><td class="memItemLeft" align="right" valign="top"><a id="a8188a57118653c6dcba7de466e572bfd"></a>
virtual <a class="el" href="structantlrcpp_1_1Any.html">antlrcpp::Any</a>&#160;</td><td class="memItemRight" valign="bottom"><b>accept</b> (tree::ParseTreeVisitor *visitor) override</td></tr>
<tr class="separator:a8188a57118653c6dcba7de466e572bfd inherit pub_methods_classantlr4_1_1RuleContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ba5cd65bf384baf9c27be9b14ebcfb inherit pub_methods_classantlr4_1_1RuleContext"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1RuleContext.html#ac4ba5cd65bf384baf9c27be9b14ebcfb">toStringTree</a> (<a class="el" href="classantlr4_1_1Parser.html">Parser</a> *recog) override</td></tr>
<tr class="memdesc:ac4ba5cd65bf384baf9c27be9b14ebcfb inherit pub_methods_classantlr4_1_1RuleContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out a whole tree, not just a node, in LISP format (root child1 .. childN). Print just a node if this is a leaf. We have to know the recognizer so we can get rule names.  <a href="classantlr4_1_1RuleContext.html#ac4ba5cd65bf384baf9c27be9b14ebcfb">More...</a><br /></td></tr>
<tr class="separator:ac4ba5cd65bf384baf9c27be9b14ebcfb inherit pub_methods_classantlr4_1_1RuleContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf82cbd07b59781b819a315a862c5a1 inherit pub_methods_classantlr4_1_1RuleContext"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1RuleContext.html#abcf82cbd07b59781b819a315a862c5a1">toStringTree</a> (std::vector&lt; std::string &gt; &amp;ruleNames)</td></tr>
<tr class="memdesc:abcf82cbd07b59781b819a315a862c5a1 inherit pub_methods_classantlr4_1_1RuleContext"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out a whole tree, not just a node, in LISP format (root child1 .. childN). Print just a node if this is a leaf.  <a href="classantlr4_1_1RuleContext.html#abcf82cbd07b59781b819a315a862c5a1">More...</a><br /></td></tr>
<tr class="separator:abcf82cbd07b59781b819a315a862c5a1 inherit pub_methods_classantlr4_1_1RuleContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94a4fb68e964f80eeeca75c24708742 inherit pub_methods_classantlr4_1_1RuleContext"><td class="memItemLeft" align="right" valign="top"><a id="ab94a4fb68e964f80eeeca75c24708742"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toStringTree</b> () override</td></tr>
<tr class="separator:ab94a4fb68e964f80eeeca75c24708742 inherit pub_methods_classantlr4_1_1RuleContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d95ea08da34f2539fb84c9386cc48f inherit pub_methods_classantlr4_1_1RuleContext"><td class="memItemLeft" align="right" valign="top"><a id="a44d95ea08da34f2539fb84c9386cc48f"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> () override</td></tr>
<tr class="separator:a44d95ea08da34f2539fb84c9386cc48f inherit pub_methods_classantlr4_1_1RuleContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3400ab115874c8ae7c8bb9b23b88b6 inherit pub_methods_classantlr4_1_1RuleContext"><td class="memItemLeft" align="right" valign="top"><a id="a5d3400ab115874c8ae7c8bb9b23b88b6"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (<a class="el" href="classantlr4_1_1Recognizer.html">Recognizer</a> *recog)</td></tr>
<tr class="separator:a5d3400ab115874c8ae7c8bb9b23b88b6 inherit pub_methods_classantlr4_1_1RuleContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fb65c70dea4528092c6fe5122a04bf inherit pub_methods_classantlr4_1_1RuleContext"><td class="memItemLeft" align="right" valign="top"><a id="a73fb65c70dea4528092c6fe5122a04bf"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (const std::vector&lt; std::string &gt; &amp;ruleNames)</td></tr>
<tr class="separator:a73fb65c70dea4528092c6fe5122a04bf inherit pub_methods_classantlr4_1_1RuleContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe90e4ee8e178f95faf2fd2f36b292be inherit pub_methods_classantlr4_1_1RuleContext"><td class="memItemLeft" align="right" valign="top"><a id="abe90e4ee8e178f95faf2fd2f36b292be"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (<a class="el" href="classantlr4_1_1Recognizer.html">Recognizer</a> *recog, <a class="el" href="classantlr4_1_1RuleContext.html">RuleContext</a> *stop)</td></tr>
<tr class="separator:abe90e4ee8e178f95faf2fd2f36b292be inherit pub_methods_classantlr4_1_1RuleContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62fa052c96061993df78332adac0430 inherit pub_methods_classantlr4_1_1RuleContext"><td class="memItemLeft" align="right" valign="top"><a id="ac62fa052c96061993df78332adac0430"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (const std::vector&lt; std::string &gt; &amp;ruleNames, <a class="el" href="classantlr4_1_1RuleContext.html">RuleContext</a> *stop)</td></tr>
<tr class="separator:ac62fa052c96061993df78332adac0430 inherit pub_methods_classantlr4_1_1RuleContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d3283be6274bee157fd0a5f5e90001 inherit pub_methods_classantlr4_1_1RuleContext"><td class="memItemLeft" align="right" valign="top"><a id="a78d3283be6274bee157fd0a5f5e90001"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classantlr4_1_1RuleContext.html">RuleContext</a> &amp;other)</td></tr>
<tr class="separator:a78d3283be6274bee157fd0a5f5e90001 inherit pub_methods_classantlr4_1_1RuleContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classantlr4_1_1tree_1_1ParseTree"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classantlr4_1_1tree_1_1ParseTree')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classantlr4_1_1tree_1_1ParseTree.html">antlr4::tree::ParseTree</a></td></tr>
<tr class="memitem:a12143657590efe85f35f76c68134d666 inherit pub_methods_classantlr4_1_1tree_1_1ParseTree"><td class="memItemLeft" align="right" valign="top"><a id="a12143657590efe85f35f76c68134d666"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ParseTree</b> (<a class="el" href="classantlr4_1_1tree_1_1ParseTree.html">ParseTree</a> const &amp;)=delete</td></tr>
<tr class="separator:a12143657590efe85f35f76c68134d666 inherit pub_methods_classantlr4_1_1tree_1_1ParseTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785332e4215830db13155e7989a15a91 inherit pub_methods_classantlr4_1_1tree_1_1ParseTree"><td class="memItemLeft" align="right" valign="top"><a id="a785332e4215830db13155e7989a15a91"></a>
<a class="el" href="classantlr4_1_1tree_1_1ParseTree.html">ParseTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classantlr4_1_1tree_1_1ParseTree.html">ParseTree</a> const &amp;)=delete</td></tr>
<tr class="separator:a785332e4215830db13155e7989a15a91 inherit pub_methods_classantlr4_1_1tree_1_1ParseTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a2e3580cf80f49dc92cec0ad4c8ea9ba0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classantlr4_1_1Token.html">Token</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1ParserRuleContext.html#a2e3580cf80f49dc92cec0ad4c8ea9ba0">start</a></td></tr>
<tr class="memdesc:a2e3580cf80f49dc92cec0ad4c8ea9ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">For debugging/tracing purposes, we want to track all of the nodes in the ATN traversed by the parser for a particular rule. This list indicates the sequence of ATN nodes used to match the elements of the children list. This list does not include ATN nodes and other rules used to match rule invocations. It traces the rule invocation node itself but nothing inside that other rule's ATN submachine.  <a href="#a2e3580cf80f49dc92cec0ad4c8ea9ba0">More...</a><br /></td></tr>
<tr class="separator:a2e3580cf80f49dc92cec0ad4c8ea9ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a3e2dbb7315e1245be9b90f93a53b5"><td class="memItemLeft" align="right" valign="top"><a id="ab5a3e2dbb7315e1245be9b90f93a53b5"></a>
<a class="el" href="classantlr4_1_1Token.html">Token</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>stop</b></td></tr>
<tr class="separator:ab5a3e2dbb7315e1245be9b90f93a53b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac427da1597154161775151dfee4069fa"><td class="memItemLeft" align="right" valign="top">std::exception_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1ParserRuleContext.html#ac427da1597154161775151dfee4069fa">exception</a></td></tr>
<tr class="separator:ac427da1597154161775151dfee4069fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classantlr4_1_1RuleContext"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classantlr4_1_1RuleContext')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classantlr4_1_1RuleContext.html">antlr4::RuleContext</a></td></tr>
<tr class="memitem:a2c4b8b84636c681f98dcd86d5c5a8459 inherit pub_attribs_classantlr4_1_1RuleContext"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1RuleContext.html#a2c4b8b84636c681f98dcd86d5c5a8459">invokingState</a></td></tr>
<tr class="separator:a2c4b8b84636c681f98dcd86d5c5a8459 inherit pub_attribs_classantlr4_1_1RuleContext"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classantlr4_1_1tree_1_1ParseTree"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classantlr4_1_1tree_1_1ParseTree')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classantlr4_1_1tree_1_1ParseTree.html">antlr4::tree::ParseTree</a></td></tr>
<tr class="memitem:a83402632670316b68280c04e6be70d50 inherit pub_attribs_classantlr4_1_1tree_1_1ParseTree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classantlr4_1_1tree_1_1ParseTree.html">ParseTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1tree_1_1ParseTree.html#a83402632670316b68280c04e6be70d50">parent</a></td></tr>
<tr class="separator:a83402632670316b68280c04e6be70d50 inherit pub_attribs_classantlr4_1_1tree_1_1ParseTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad52b12c9e03c4a117e1ac00bba74073 inherit pub_attribs_classantlr4_1_1tree_1_1ParseTree"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classantlr4_1_1tree_1_1ParseTree.html">ParseTree</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classantlr4_1_1tree_1_1ParseTree.html#aad52b12c9e03c4a117e1ac00bba74073">children</a></td></tr>
<tr class="separator:aad52b12c9e03c4a117e1ac00bba74073 inherit pub_attribs_classantlr4_1_1tree_1_1ParseTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a41d719f482d60677ec1fbf08b7e5e77c"><td class="memItemLeft" align="right" valign="top"><a id="a41d719f482d60677ec1fbf08b7e5e77c"></a>
static <a class="el" href="classantlr4_1_1ParserRuleContext.html">ParserRuleContext</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EMPTY</b></td></tr>
<tr class="separator:a41d719f482d60677ec1fbf08b7e5e77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A rule invocation record for parsing. </p>
<p>Contains all of the information about the current rule not stored in the <a class="el" href="classantlr4_1_1RuleContext.html">RuleContext</a>. It handles parse tree children list, Any ATN state tracing, and the default values available for rule invocatons: start, stop, rule index, current alt number.</p>
<p>Subclasses made for each rule and grammar track the parameters, return values, locals, and labels specific to that rule. These are the objects that are returned from rules.</p>
<p>Note text is not an actual field of a rule return value; it is computed from start and stop using the input stream's toString() method. I could add a ctor to this so that we can pass in and store the input stream, but I'm not sure we want to do that. It would seem to be undefined to get the .text property anyway if the rule matches tokens from multiple input streams.</p>
<p>I do not use getters for fields of objects that are used simply to group values such as this aggregate. The getters/setters are there to satisfy the superclass interface. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a402addbef275358076e63253db77b0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402addbef275358076e63253db77b0c4">&#9670;&nbsp;</a></span>addChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classantlr4_1_1tree_1_1TerminalNode.html">tree::TerminalNode</a> * ParserRuleContext::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classantlr4_1_1tree_1_1TerminalNode.html">tree::TerminalNode</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a token leaf node child and force its parent to be this node. </p>

</div>
</div>
<a id="a32e160f0c98a6475424ffe193040cdae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e160f0c98a6475424ffe193040cdae">&#9670;&nbsp;</a></span>copyFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParserRuleContext::copyFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classantlr4_1_1ParserRuleContext.html">ParserRuleContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>COPY a ctx (I'm deliberately not using copy constructor) to avoid confusion with creating node with parent. Does not copy children (except error leaves). </p>

</div>
</div>
<a id="a069cff86aad00ea0618985e78291e8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069cff86aad00ea0618985e78291e8fa">&#9670;&nbsp;</a></span>getStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classantlr4_1_1Token.html">Token</a> * ParserRuleContext::getStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the initial token in this context. Note that the range from start to stop is inclusive, so for rules that do not consume anything (for example, zero length or error productions) this token may exceed stop. </p>

</div>
</div>
<a id="a51432e71c46225602c504768c50ad776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51432e71c46225602c504768c50ad776">&#9670;&nbsp;</a></span>getStop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classantlr4_1_1Token.html">Token</a> * ParserRuleContext::getStop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the final token in this context. Note that the range from start to stop is inclusive, so for rules that do not consume anything (for example, zero length or error productions) this token may precede start. </p>

</div>
</div>
<a id="a0d7e71fc8e12b036014820a1d530b8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7e71fc8e12b036014820a1d530b8bb">&#9670;&nbsp;</a></span>removeLastChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParserRuleContext::removeLastChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used by enterOuterAlt to toss out a <a class="el" href="classantlr4_1_1RuleContext.html">RuleContext</a> previously added as we entered a rule. If we have # label, we will need to remove generic ruleContext object. </p>

</div>
</div>
<a id="a36fdb4f19d0b2dce76164b3ffee6d81e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36fdb4f19d0b2dce76164b3ffee6d81e">&#9670;&nbsp;</a></span>toInfoString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParserRuleContext::toInfoString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classantlr4_1_1Parser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>recognizer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for rule context info debugging during parse-time, not so much for ATN debugging </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac427da1597154161775151dfee4069fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac427da1597154161775151dfee4069fa">&#9670;&nbsp;</a></span>exception</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::exception_ptr antlr4::ParserRuleContext::exception</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The exception that forced this rule to return. If the rule successfully completed, this is "null exception pointer". </p>

</div>
</div>
<a id="a2e3580cf80f49dc92cec0ad4c8ea9ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3580cf80f49dc92cec0ad4c8ea9ba0">&#9670;&nbsp;</a></span>start</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classantlr4_1_1Token.html">Token</a>* antlr4::ParserRuleContext::start</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For debugging/tracing purposes, we want to track all of the nodes in the ATN traversed by the parser for a particular rule. This list indicates the sequence of ATN nodes used to match the elements of the children list. This list does not include ATN nodes and other rules used to match rule invocations. It traces the rule invocation node itself but nothing inside that other rule's ATN submachine. </p>
<p>There is NOT a one-to-one correspondence between the children and states list. There are typically many nodes in the ATN traversed for each element in the children list. For example, for a rule invocation there is the invoking state and the following state.</p>
<p>The parser setState() method updates field s and adds it to this list if we are debugging/tracing.</p>
<p>This does not trace states visited during prediction. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ParserRuleContext_8h_source.html">ParserRuleContext.h</a></li>
<li>ParserRuleContext.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
