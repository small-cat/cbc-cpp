# 类型系统的目标

1 确保运行时的安全性

类顶推断： 为代码中的每个名字和每个表达式确定一种类型的过程

隐式类型转换和显示类型转换

2 提高表达力

运算符重载：如果运算符的语义是根据其参数类型确定的，那么该运算符就被认为是“重载”的。比如c语言中的类型信息确定了指针递增的实际效果，地址实际增加的量由指针的类型确定

3 生成更好的代码

4 类型检查

类型检查，实际上做了类型推断和识别类型相关错误的工作

# 类型系统的组件

## 基础类型

也称为内建类型

cbc 的内建类型，目前仅支持整数，为

```
VOID
CHAR
SHORT
INT
LONG
UNSIGNED CHAR
UNSIGNED SHORT
UNSIGNED INT
UNSIGNED LONG
```

bool 类型考虑添加上

## 复合类型和构造类型

通过现行类型构建新类型

- 数组
- 串

在 c 中，只有字符，串以字符数组的形式存在，但是真正的串，与数组还是不同的。对串有意义的操作，比如连接，转换和计算长度数组可能没有对应的操作

- 枚举

编译器将枚举的各个类型，分别映射为不同的值。比较同一枚举类型的成员是有意义的，但是比较不同枚举类型的值是没有意义的，应该生成 type_error 的错误。

- 结构体和变体

结构，也成为记录，将多个任意类型的对象聚集在一起。结构的类型是各个成员类型的有序笛卡尔积。比如 c 中的 `struct`。

有些语言允许通过其他类型的并集建立新的类型，比如 c 中的 `union`。

- 指针

指针是抽象的内存地址，使得程序员可以操控任意数据结构。

> 地址运算符在应用到类型为 t 的对象时返回一个值，其类型为指向 t 的指针

为防止使用指向类型 t 的指针引用类型 s 的结构实例，可以对语言做如下限制：限制对指针的赋值，只能使用“等价”类型的地址。即，赋值运算符左侧的指针所指向的类型必须与赋值运算符右侧的表达式本身的类型相同，也就是说，int 类型的指针，只能被赋值为表达式类型为int 的表达式，否则就是类型错误，`type_error`

## 类型等价性

确定两种类型是否等价或者兼容

名字等价性： 类型名称相同

结构等价性：二者具有相同的结构。具有相同的组成字段，字段排列顺序相同，且对应的字段具有等价的类型。

## 用于推断的规则

为每个源语言表达式推断类型的规则。一般会对每个运算符规定操作数类型和结果类型之间的映射。比如

![type deduce](./img/type_deduce.png)

一些语言要求编译器执行隐式类型转换。编译器必须识别出某些组合种类的混合类型表达式，并通过插入适当转换的方式进行处理。比如 c 语言中

```
int a = 3 + 0.4;
```

隐式类型转换，首先将 3 转换成 float，然后将相加后的结果再隐式转换成 int 赋值给 a

- 申明和推断

有些语言，比如 c 语言，就设计成 “先申明后使用” 的规则。这种请执行申明的引入，能够确保使用的变量都有着明确的类型。

为常量分配类型时，在语法分析阶段，能够根据常量的规则提前做出判断，比如字符串，比如整数或者浮点数。但是比如 c++ 中的 auto 关键字，就需要进行类型推断。比如 

```
auto x = 2;
```

因为 2 是整数，编译器需要推断出变量 x 的类型也是整型 int

## 推断表达式的类型

为程序中出现的每一个表达式分配一个类型。最简单的情形，就是表达式语法分析树中的每个叶结点都可以分配类型。编译器可以在后续遍历语法树时为表达式中的每一个值分配一个类型。这也是那些 **先申明后使用** 规则的语言的一个方便之处。当然，类似于 c 中的函数申明，比如明确指明返回值类型，这也就明确制定了该函数表达式的类型。

## 类型推断的过程间相关问题

函数签名