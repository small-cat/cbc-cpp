**静态类型检查**

# 类型定义的检查

- 检查 array，struct，union 是否包含有 void 类型成员

  比如 void[3] 这种错误的定义

- 检查 struct，union 是否包含重复的成员

- 检查 struct，union 是否循环定义，即是否存在环

  比如

  ```
  struct point {
  	struct point; // 如果是指针是正确的，直接的定义就是错误的
  };
  ```

  或者

  ```
  struct point_x {
  struct point_y y;
  };
  typedef struct point_x my_point_x;
  struct point_y {
  my_point_x x;
  };
  ```


# 表达式的有效性检查

- 为无法赋值的表达式赋值(例:1= 2 + 2)
- 使用非法的函数名调用函数(例:"string"("%d\n",i))
- 操作数非法的数组引用(例: 1[0])
- 操作数非法的成员引用(例: 1.memb)
- 操作数非法的指针间接引用(例: 1->memb)
- 对非指针的对象取值(例:*1)
- 对非左值的表达式取地址

# 静态类型检查

静态类型检查，包括类型检查和隐式类型转换。

**NOTE： 当前存在的一些限制，也是为实现的部分。 函数返回值不能是 struct 或者 union，且 struct 或者 union 类型不能直接进行赋值操作**


| 检查对象的表达式 | 限制 |
| ---- | ---- |
|变量 | 除 void 类型以外|
|赋值的左值 | 整数或指针|
|函数的返回值 | 整数或指针|
|函数的形参 | 整数或指针或数组|
|函数的实参 | 整数或指针或数组|
|return 的值 | 整数或指针或数组,并且符合函数的定义|
|条件表达式 | 整数或指针或数组|
|switch 语句的条件表达式 | 整数|
|c?t:e | t 和 e 为相同类型的整数、指针、数组|
|x + y | x 和 y 分别是指针和整数,或者是类型相同的整数|
|x - y | x 和 y 分别是指针和整数,或者是类型相同的整数|
|x * y | x 和 y 是类型相同的整数|
|x / y | x 和 y 是类型相同的整数|
|x % y | x 和 y 是类型相同的整数|
|x & y | x 和 y 是类型相同的整数|
|x \| y | x 和 y 是类型相同的整数 |
|x ^ y | x 和 y 是类型相同的整数|
|x << y | x 和 y 是类型相同的整数|
|x >> y | x 和 y 是类型相同的整数|
|x == y | x 和 y 是类型相同的整数、指针、数组|
|x != y | x 和 y 是类型相同的整数、指针、数组|
|x < y | x 和 y 是类型相同的整数、指针、数组|
|x <= y | x 和 y 是类型相同的整数、指针、数组|
|x > y | x 和 y 是类型相同的整数、指针、数组|
|x >= y | x 和 y 是类型相同的整数、指针、数组|
|x && y | x 和 y 是类型相同的整数|
|x \|\| y |x 和 y 是类型相同的整数|
|+x | x 是整数|
|-x | x 是整数|
|~x | x 是整数|
|!x | x 是整数或指针或数组|
|++x | x 是整数或指针|
|--x | x 是整数或指针|
|x++ | x 是整数或指针|
|x-- | x 是整数或指针|
|f(a) | f 是函数指针,a 符合函数 f 的定义|
|a[i] | a 是指针或数组,i 是整数|
|*p | p 是指针或数组 |
|&x | x 为左值 |
|(t)x | x 的类型可转换为类型 t|

指针，可以是 *p 类型的变量，也可以是函数指针，也可以是作为函数行参的数组

## 隐式类型转换

1. 首先将 signed char、unsigned char、signed short、unsigned short 转换为 signed int,再按照下述步骤比较两者的类型

2. 按照 unsigned long、signed long、unsigned int、signed int 的优先顺序选用类型,使两者的类型相一致

3. 只有当一方为 unsigned int,另一方为 signed long 时 , 要例外地统一成 unsigned long

静态类型转换需要